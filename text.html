<!DOCTYPE html>
<html lang="en-US">

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
		<link rel="stylesheet" type="text/css" href="style.css" />
		<link rel="stylesheet" type="text/css" href="http://code.jquery.com/ui/1.10.0/themes/base/jquery-ui.css" />
		<script  > /*! jQuery v1.9.0 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license */(function(e,t){"use strict";function n(e){var t=e.length,n=st.type(e);return st.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}function r(e){var t=Tt[e]={};return st.each(e.match(lt)||[],function(e,n){t[n]=!0}),t}function i(e,n,r,i){if(st.acceptData(e)){var o,a,s=st.expando,u="string"==typeof n,l=e.nodeType,c=l?st.cache:e,f=l?e[s]:e[s]&&s;if(f&&c[f]&&(i||c[f].data)||!u||r!==t)return f||(l?e[s]=f=K.pop()||st.guid++:f=s),c[f]||(c[f]={},l||(c[f].toJSON=st.noop)),("object"==typeof n||"function"==typeof n)&&(i?c[f]=st.extend(c[f],n):c[f].data=st.extend(c[f].data,n)),o=c[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[st.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[st.camelCase(n)])):a=o,a}}function o(e,t,n){if(st.acceptData(e)){var r,i,o,a=e.nodeType,u=a?st.cache:e,l=a?e[st.expando]:st.expando;if(u[l]){if(t&&(r=n?u[l]:u[l].data)){st.isArray(t)?t=t.concat(st.map(t,st.camelCase)):t in r?t=[t]:(t=st.camelCase(t),t=t in r?[t]:t.split(" "));for(i=0,o=t.length;o>i;i++)delete r[t[i]];if(!(n?s:st.isEmptyObject)(r))return}(n||(delete u[l].data,s(u[l])))&&(a?st.cleanData([e],!0):st.support.deleteExpando||u!=u.window?delete u[l]:u[l]=null)}}}function a(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(Nt,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:wt.test(r)?st.parseJSON(r):r}catch(o){}st.data(e,n,r)}else r=t}return r}function s(e){var t;for(t in e)if(("data"!==t||!st.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}function u(){return!0}function l(){return!1}function c(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}function f(e,t,n){if(t=t||0,st.isFunction(t))return st.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return st.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=st.grep(e,function(e){return 1===e.nodeType});if(Wt.test(t))return st.filter(t,r,!n);t=st.filter(t,r)}return st.grep(e,function(e){return st.inArray(e,t)>=0===n})}function p(e){var t=zt.split("|"),n=e.createDocumentFragment();if(n.createElement)for(;t.length;)n.createElement(t.pop());return n}function d(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function h(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function g(e){var t=nn.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function m(e,t){for(var n,r=0;null!=(n=e[r]);r++)st._data(n,"globalEval",!t||st._data(t[r],"globalEval"))}function y(e,t){if(1===t.nodeType&&st.hasData(e)){var n,r,i,o=st._data(e),a=st._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)st.event.add(t,n,s[n][r])}a.data&&(a.data=st.extend({},a.data))}}function v(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!st.support.noCloneEvent&&t[st.expando]){r=st._data(t);for(i in r.events)st.removeEvent(t,i,r.handle);t.removeAttribute(st.expando)}"script"===n&&t.text!==e.text?(h(t).text=e.text,g(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),st.support.html5Clone&&e.innerHTML&&!st.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Zt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}function b(e,n){var r,i,o=0,a=e.getElementsByTagName!==t?e.getElementsByTagName(n||"*"):e.querySelectorAll!==t?e.querySelectorAll(n||"*"):t;if(!a)for(a=[],r=e.childNodes||e;null!=(i=r[o]);o++)!n||st.nodeName(i,n)?a.push(i):st.merge(a,b(i,n));return n===t||n&&st.nodeName(e,n)?st.merge([e],a):a}function x(e){Zt.test(e.type)&&(e.defaultChecked=e.checked)}function T(e,t){if(t in e)return t;for(var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Nn.length;i--;)if(t=Nn[i]+n,t in e)return t;return r}function w(e,t){return e=t||e,"none"===st.css(e,"display")||!st.contains(e.ownerDocument,e)}function N(e,t){for(var n,r=[],i=0,o=e.length;o>i;i++)n=e[i],n.style&&(r[i]=st._data(n,"olddisplay"),t?(r[i]||"none"!==n.style.display||(n.style.display=""),""===n.style.display&&w(n)&&(r[i]=st._data(n,"olddisplay",S(n.nodeName)))):r[i]||w(n)||st._data(n,"olddisplay",st.css(n,"display")));for(i=0;o>i;i++)n=e[i],n.style&&(t&&"none"!==n.style.display&&""!==n.style.display||(n.style.display=t?r[i]||"":"none"));return e}function C(e,t,n){var r=mn.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function k(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;4>o;o+=2)"margin"===n&&(a+=st.css(e,n+wn[o],!0,i)),r?("content"===n&&(a-=st.css(e,"padding"+wn[o],!0,i)),"margin"!==n&&(a-=st.css(e,"border"+wn[o]+"Width",!0,i))):(a+=st.css(e,"padding"+wn[o],!0,i),"padding"!==n&&(a+=st.css(e,"border"+wn[o]+"Width",!0,i)));return a}function E(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=ln(e),a=st.support.boxSizing&&"border-box"===st.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=un(e,t,o),(0>i||null==i)&&(i=e.style[t]),yn.test(i))return i;r=a&&(st.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+k(e,t,n||(a?"border":"content"),r,o)+"px"}function S(e){var t=V,n=bn[e];return n||(n=A(e,t),"none"!==n&&n||(cn=(cn||st("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(cn[0].contentWindow||cn[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=A(e,t),cn.detach()),bn[e]=n),n}function A(e,t){var n=st(t.createElement(e)).appendTo(t.body),r=st.css(n[0],"display");return n.remove(),r}function j(e,t,n,r){var i;if(st.isArray(t))st.each(t,function(t,i){n||kn.test(e)?r(e,i):j(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==st.type(t))r(e,t);else for(i in t)j(e+"["+i+"]",t[i],n,r)}function D(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(lt)||[];if(st.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function L(e,n,r,i){function o(u){var l;return a[u]=!0,st.each(e[u]||[],function(e,u){var c=u(n,r,i);return"string"!=typeof c||s||a[c]?s?!(l=c):t:(n.dataTypes.unshift(c),o(c),!1)}),l}var a={},s=e===$n;return o(n.dataTypes[0])||!a["*"]&&o("*")}function H(e,n){var r,i,o=st.ajaxSettings.flatOptions||{};for(r in n)n[r]!==t&&((o[r]?e:i||(i={}))[r]=n[r]);return i&&st.extend(!0,e,i),e}function M(e,n,r){var i,o,a,s,u=e.contents,l=e.dataTypes,c=e.responseFields;for(o in c)o in r&&(n[c[o]]=r[o]);for(;"*"===l[0];)l.shift(),i===t&&(i=e.mimeType||n.getResponseHeader("Content-Type"));if(i)for(o in u)if(u[o]&&u[o].test(i)){l.unshift(o);break}if(l[0]in r)a=l[0];else{for(o in r){if(!l[0]||e.converters[o+" "+l[0]]){a=o;break}s||(s=o)}a=a||s}return a?(a!==l[0]&&l.unshift(a),r[a]):t}function q(e,t){var n,r,i,o,a={},s=0,u=e.dataTypes.slice(),l=u[0];if(e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u[1])for(n in e.converters)a[n.toLowerCase()]=e.converters[n];for(;i=u[++s];)if("*"!==i){if("*"!==l&&l!==i){if(n=a[l+" "+i]||a["* "+i],!n)for(r in a)if(o=r.split(" "),o[1]===i&&(n=a[l+" "+o[0]]||a["* "+o[0]])){n===!0?n=a[r]:a[r]!==!0&&(i=o[0],u.splice(s--,0,i));break}if(n!==!0)if(n&&e["throws"])t=n(t);else try{t=n(t)}catch(c){return{state:"parsererror",error:n?c:"No conversion from "+l+" to "+i}}}l=i}return{state:"success",data:t}}function _(){try{return new e.XMLHttpRequest}catch(t){}}function F(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function O(){return setTimeout(function(){Qn=t}),Qn=st.now()}function B(e,t){st.each(t,function(t,n){for(var r=(rr[t]||[]).concat(rr["*"]),i=0,o=r.length;o>i;i++)if(r[i].call(e,t,n))return})}function P(e,t,n){var r,i,o=0,a=nr.length,s=st.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=Qn||O(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:st.extend({},t),opts:st.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Qn||O(),duration:n.duration,tweens:[],createTween:function(t,n){var r=st.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?s.resolveWith(e,[l,t]):s.rejectWith(e,[l,t]),this}}),c=l.props;for(R(c,l.opts.specialEasing);a>o;o++)if(r=nr[o].call(l,e,c,l.opts))return r;return B(l,c),st.isFunction(l.opts.start)&&l.opts.start.call(e,l),st.fx.timer(st.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function R(e,t){var n,r,i,o,a;for(n in e)if(r=st.camelCase(n),i=t[r],o=e[n],st.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=st.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function W(e,t,n){var r,i,o,a,s,u,l,c,f,p=this,d=e.style,h={},g=[],m=e.nodeType&&w(e);n.queue||(c=st._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,f=c.empty.fire,c.empty.fire=function(){c.unqueued||f()}),c.unqueued++,p.always(function(){p.always(function(){c.unqueued--,st.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],"inline"===st.css(e,"display")&&"none"===st.css(e,"float")&&(st.support.inlineBlockNeedsLayout&&"inline"!==S(e.nodeName)?d.zoom=1:d.display="inline-block")),n.overflow&&(d.overflow="hidden",st.support.shrinkWrapBlocks||p.done(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(r in t)if(o=t[r],Zn.exec(o)){if(delete t[r],u=u||"toggle"===o,o===(m?"hide":"show"))continue;g.push(r)}if(a=g.length){s=st._data(e,"fxshow")||st._data(e,"fxshow",{}),"hidden"in s&&(m=s.hidden),u&&(s.hidden=!m),m?st(e).show():p.done(function(){st(e).hide()}),p.done(function(){var t;st._removeData(e,"fxshow");for(t in h)st.style(e,t,h[t])});for(r=0;a>r;r++)i=g[r],l=p.createTween(i,m?s[i]:0),h[i]=s[i]||st.style(e,i),i in s||(s[i]=l.start,m&&(l.end=l.start,l.start="width"===i||"height"===i?1:0))}}function $(e,t,n,r,i){return new $.prototype.init(e,t,n,r,i)}function I(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=wn[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function z(e){return st.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}var X,U,V=e.document,Y=e.location,J=e.jQuery,G=e.$,Q={},K=[],Z="1.9.0",et=K.concat,tt=K.push,nt=K.slice,rt=K.indexOf,it=Q.toString,ot=Q.hasOwnProperty,at=Z.trim,st=function(e,t){return new st.fn.init(e,t,X)},ut=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,lt=/\S+/g,ct=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,ft=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,pt=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,dt=/^[\],:{}\s]*$/,ht=/(?:^|:|,)(?:\s*\[)+/g,gt=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,mt=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,yt=/^-ms-/,vt=/-([\da-z])/gi,bt=function(e,t){return t.toUpperCase()},xt=function(){V.addEventListener?(V.removeEventListener("DOMContentLoaded",xt,!1),st.ready()):"complete"===V.readyState&&(V.detachEvent("onreadystatechange",xt),st.ready())};st.fn=st.prototype={jquery:Z,constructor:st,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:ft.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof st?n[0]:n,st.merge(this,st.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:V,!0)),pt.test(i[1])&&st.isPlainObject(n))for(i in n)st.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=V.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=V,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):st.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),st.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return nt.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=st.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return st.each(this,e,t)},ready:function(e){return st.ready.promise().done(e),this},slice:function(){return this.pushStack(nt.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(st.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:tt,sort:[].sort,splice:[].splice},st.fn.init.prototype=st.fn,st.extend=st.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||st.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(e=arguments[u]))for(n in e)r=s[n],i=e[n],s!==i&&(c&&i&&(st.isPlainObject(i)||(o=st.isArray(i)))?(o?(o=!1,a=r&&st.isArray(r)?r:[]):a=r&&st.isPlainObject(r)?r:{},s[n]=st.extend(c,a,i)):i!==t&&(s[n]=i));return s},st.extend({noConflict:function(t){return e.$===st&&(e.$=G),t&&e.jQuery===st&&(e.jQuery=J),st},isReady:!1,readyWait:1,holdReady:function(e){e?st.readyWait++:st.ready(!0)},ready:function(e){if(e===!0?!--st.readyWait:!st.isReady){if(!V.body)return setTimeout(st.ready);st.isReady=!0,e!==!0&&--st.readyWait>0||(U.resolveWith(V,[st]),st.fn.trigger&&st(V).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===st.type(e)},isArray:Array.isArray||function(e){return"array"===st.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?Q[it.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==st.type(e)||e.nodeType||st.isWindow(e))return!1;try{if(e.constructor&&!ot.call(e,"constructor")&&!ot.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||ot.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||V;var r=pt.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=st.buildFragment([e],t,i),i&&st(i).remove(),st.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=st.trim(n),n&&dt.test(n.replace(gt,"@").replace(mt,"]").replace(ht,"")))?Function("return "+n)():(st.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||st.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&st.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(yt,"ms-").replace(vt,bt)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,r){var i,o=0,a=e.length,s=n(e);if(r){if(s)for(;a>o&&(i=t.apply(e[o],r),i!==!1);o++);else for(o in e)if(i=t.apply(e[o],r),i===!1)break}else if(s)for(;a>o&&(i=t.call(e[o],o,e[o]),i!==!1);o++);else for(o in e)if(i=t.call(e[o],o,e[o]),i===!1)break;return e},trim:at&&!at.call("\ufeff\u00a0")?function(e){return null==e?"":at.call(e)}:function(e){return null==e?"":(e+"").replace(ct,"")},makeArray:function(e,t){var r=t||[];return null!=e&&(n(Object(e))?st.merge(r,"string"==typeof e?[e]:e):tt.call(r,e)),r},inArray:function(e,t,n){var r;if(t){if(rt)return rt.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else for(;n[o]!==t;)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,r){var i,o=0,a=e.length,s=n(e),u=[];if(s)for(;a>o;o++)i=t(e[o],o,r),null!=i&&(u[u.length]=i);else for(o in e)i=t(e[o],o,r),null!=i&&(u[u.length]=i);return et.apply([],u)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(r=e[n],n=e,e=r),st.isFunction(e)?(i=nt.call(arguments,2),o=function(){return e.apply(n||this,i.concat(nt.call(arguments)))},o.guid=e.guid=e.guid||st.guid++,o):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===st.type(r)){o=!0;for(u in r)st.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,st.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(st(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),st.ready.promise=function(t){if(!U)if(U=st.Deferred(),"complete"===V.readyState)setTimeout(st.ready);else if(V.addEventListener)V.addEventListener("DOMContentLoaded",xt,!1),e.addEventListener("load",st.ready,!1);else{V.attachEvent("onreadystatechange",xt),e.attachEvent("onload",st.ready);var n=!1;try{n=null==e.frameElement&&V.documentElement}catch(r){}n&&n.doScroll&&function i(){if(!st.isReady){try{n.doScroll("left")}catch(e){return setTimeout(i,50)}st.ready()}}()}return U.promise(t)},st.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){Q["[object "+t+"]"]=t.toLowerCase()}),X=st(V);var Tt={};st.Callbacks=function(e){e="string"==typeof e?Tt[e]||r(e):st.extend({},e);var n,i,o,a,s,u,l=[],c=!e.once&&[],f=function(t){for(n=e.memory&&t,i=!0,u=a||0,a=0,s=l.length,o=!0;l&&s>u;u++)if(l[u].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}o=!1,l&&(c?c.length&&f(c.shift()):n?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function r(t){st.each(t,function(t,n){var i=st.type(n);"function"===i?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==i&&r(n)})})(arguments),o?s=l.length:n&&(a=t,f(n))}return this},remove:function(){return l&&st.each(arguments,function(e,t){for(var n;(n=st.inArray(t,l,n))>-1;)l.splice(n,1),o&&(s>=n&&s--,u>=n&&u--)}),this},has:function(e){return st.inArray(e,l)>-1},empty:function(){return l=[],this},disable:function(){return l=c=n=t,this},disabled:function(){return!l},lock:function(){return c=t,n||p.disable(),this},locked:function(){return!c},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!l||i&&!c||(o?c.push(t):f(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},st.extend({Deferred:function(e){var t=[["resolve","done",st.Callbacks("once memory"),"resolved"],["reject","fail",st.Callbacks("once memory"),"rejected"],["notify","progress",st.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return st.Deferred(function(n){st.each(t,function(t,o){var a=o[0],s=st.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&st.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?st.extend(e,r):r}},i={};return r.pipe=r.then,st.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t,n,r,i=0,o=nt.call(arguments),a=o.length,s=1!==a||e&&st.isFunction(e.promise)?a:0,u=1===s?e:st.Deferred(),l=function(e,n,r){return function(i){n[e]=this,r[e]=arguments.length>1?nt.call(arguments):i,r===t?u.notifyWith(n,r):--s||u.resolveWith(n,r)}};if(a>1)for(t=Array(a),n=Array(a),r=Array(a);a>i;i++)o[i]&&st.isFunction(o[i].promise)?o[i].promise().done(l(i,r,o)).fail(u.reject).progress(l(i,n,t)):--s;return s||u.resolveWith(r,o),u.promise()}}),st.support=function(){var n,r,i,o,a,s,u,l,c,f,p=V.createElement("div");if(p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",r=p.getElementsByTagName("*"),i=p.getElementsByTagName("a")[0],!r||!i||!r.length)return{};o=V.createElement("select"),a=o.appendChild(V.createElement("option")),s=p.getElementsByTagName("input")[0],i.style.cssText="top:1px;float:left;opacity:.5",n={getSetAttribute:"t"!==p.className,leadingWhitespace:3===p.firstChild.nodeType,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(i.getAttribute("style")),hrefNormalized:"/a"===i.getAttribute("href"),opacity:/^0.5/.test(i.style.opacity),cssFloat:!!i.style.cssFloat,checkOn:!!s.value,optSelected:a.selected,enctype:!!V.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==V.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===V.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},s.checked=!0,n.noCloneChecked=s.cloneNode(!0).checked,o.disabled=!0,n.optDisabled=!a.disabled;try{delete p.test}catch(d){n.deleteExpando=!1}s=V.createElement("input"),s.setAttribute("value",""),n.input=""===s.getAttribute("value"),s.value="t",s.setAttribute("type","radio"),n.radioValue="t"===s.value,s.setAttribute("checked","t"),s.setAttribute("name","t"),u=V.createDocumentFragment(),u.appendChild(s),n.appendChecked=s.checked,n.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,p.attachEvent&&(p.attachEvent("onclick",function(){n.noCloneEvent=!1}),p.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})p.setAttribute(l="on"+f,"t"),n[f+"Bubbles"]=l in e||p.attributes[l].expando===!1;return p.style.backgroundClip="content-box",p.cloneNode(!0).style.backgroundClip="",n.clearCloneStyle="content-box"===p.style.backgroundClip,st(function(){var r,i,o,a="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",s=V.getElementsByTagName("body")[0];s&&(r=V.createElement("div"),r.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",s.appendChild(r).appendChild(p),p.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=p.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",c=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",n.reliableHiddenOffsets=c&&0===o[0].offsetHeight,p.innerHTML="",p.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",n.boxSizing=4===p.offsetWidth,n.doesNotIncludeMarginInBodyOffset=1!==s.offsetTop,e.getComputedStyle&&(n.pixelPosition="1%"!==(e.getComputedStyle(p,null)||{}).top,n.boxSizingReliable="4px"===(e.getComputedStyle(p,null)||{width:"4px"}).width,i=p.appendChild(V.createElement("div")),i.style.cssText=p.style.cssText=a,i.style.marginRight=i.style.width="0",p.style.width="1px",n.reliableMarginRight=!parseFloat((e.getComputedStyle(i,null)||{}).marginRight)),p.style.zoom!==t&&(p.innerHTML="",p.style.cssText=a+"width:1px;padding:1px;display:inline;zoom:1",n.inlineBlockNeedsLayout=3===p.offsetWidth,p.style.display="block",p.innerHTML="<div></div>",p.firstChild.style.width="5px",n.shrinkWrapBlocks=3!==p.offsetWidth,s.style.zoom=1),s.removeChild(r),r=p=o=i=null)}),r=o=u=a=i=s=null,n}();var wt=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,Nt=/([A-Z])/g;st.extend({cache:{},expando:"jQuery"+(Z+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?st.cache[e[st.expando]]:e[st.expando],!!e&&!s(e)},data:function(e,t,n){return i(e,t,n,!1)},removeData:function(e,t){return o(e,t,!1)},_data:function(e,t,n){return i(e,t,n,!0)},_removeData:function(e,t){return o(e,t,!0)},acceptData:function(e){var t=e.nodeName&&st.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),st.fn.extend({data:function(e,n){var r,i,o=this[0],s=0,u=null;if(e===t){if(this.length&&(u=st.data(o),1===o.nodeType&&!st._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>s;s++)i=r[s].name,i.indexOf("data-")||(i=st.camelCase(i.substring(5)),a(o,i,u[i]));st._data(o,"parsedAttrs",!0)}return u}return"object"==typeof e?this.each(function(){st.data(this,e)}):st.access(this,function(n){return n===t?o?a(o,e,st.data(o,e)):null:(this.each(function(){st.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){st.removeData(this,e)})}}),st.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=st._data(e,n),r&&(!i||st.isArray(r)?i=st._data(e,n,st.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=st.queue(e,t),r=n.length,i=n.shift(),o=st._queueHooks(e,t),a=function(){st.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return st._data(e,n)||st._data(e,n,{empty:st.Callbacks("once memory").add(function(){st._removeData(e,t+"queue"),st._removeData(e,n)})})}}),st.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?st.queue(this[0],e):n===t?this:this.each(function(){var t=st.queue(this,e,n);st._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&st.dequeue(this,e)})},dequeue:function(e){return this.each(function(){st.dequeue(this,e)})},delay:function(e,t){return e=st.fx?st.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=st.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};for("string"!=typeof e&&(n=e,e=t),e=e||"fx";s--;)r=st._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var Ct,kt,Et=/[\t\r\n]/g,St=/\r/g,At=/^(?:input|select|textarea|button|object)$/i,jt=/^(?:a|area)$/i,Dt=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,Lt=/^(?:checked|selected)$/i,Ht=st.support.getSetAttribute,Mt=st.support.input;st.fn.extend({attr:function(e,t){return st.access(this,st.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){st.removeAttr(this,e)})},prop:function(e,t){return st.access(this,st.prop,e,t,arguments.length>1)},removeProp:function(e){return e=st.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(st.isFunction(e))return this.each(function(t){st(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(lt)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(Et," "):" ")){for(o=0;i=t[o++];)0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=st.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(st.isFunction(e))return this.each(function(t){st(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(lt)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(Et," "):"")){for(o=0;i=t[o++];)for(;r.indexOf(" "+i+" ")>=0;)r=r.replace(" "+i+" "," ");n.className=e?st.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return st.isFunction(e)?this.each(function(n){st(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n)for(var i,o=0,a=st(this),s=t,u=e.match(lt)||[];i=u[o++];)s=r?s:!a.hasClass(i),a[s?"addClass":"removeClass"](i);else("undefined"===n||"boolean"===n)&&(this.className&&st._data(this,"__className__",this.className),this.className=this.className||e===!1?"":st._data(this,"__className__")||"")})},hasClass:function(e){for(var t=" "+e+" ",n=0,r=this.length;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(Et," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=st.isFunction(e),this.each(function(r){var o,a=st(this);1===this.nodeType&&(o=i?e.call(this,r,a.val()):e,null==o?o="":"number"==typeof o?o+="":st.isArray(o)&&(o=st.map(o,function(e){return null==e?"":e+""})),n=st.valHooks[this.type]||st.valHooks[this.nodeName.toLowerCase()],n&&"set"in n&&n.set(this,o,"value")!==t||(this.value=o))});if(o)return n=st.valHooks[o.type]||st.valHooks[o.nodeName.toLowerCase()],n&&"get"in n&&(r=n.get(o,"value"))!==t?r:(r=o.value,"string"==typeof r?r.replace(St,""):null==r?"":r)}}}),st.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(st.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&st.nodeName(n.parentNode,"optgroup"))){if(t=st(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=st.makeArray(t);return st(e).find("option").each(function(){this.selected=st.inArray(st(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return e.getAttribute===t?st.prop(e,n,r):(a=1!==s||!st.isXMLDoc(e),a&&(n=n.toLowerCase(),o=st.attrHooks[n]||(Dt.test(n)?kt:Ct)),r===t?o&&a&&"get"in o&&null!==(i=o.get(e,n))?i:(e.getAttribute!==t&&(i=e.getAttribute(n)),null==i?t:i):null!==r?o&&a&&"set"in o&&(i=o.set(e,r,n))!==t?i:(e.setAttribute(n,r+""),r):(st.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(lt);if(o&&1===e.nodeType)for(;n=o[i++];)r=st.propFix[n]||n,Dt.test(n)?!Ht&&Lt.test(n)?e[st.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:st.attr(e,n,""),e.removeAttribute(Ht?n:r)},attrHooks:{type:{set:function(e,t){if(!st.support.radioValue&&"radio"===t&&st.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!st.isXMLDoc(e),a&&(n=st.propFix[n]||n,o=st.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):At.test(e.nodeName)||jt.test(e.nodeName)&&e.href?0:t}}}}),kt={get:function(e,n){var r=st.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?Mt&&Ht?null!=i:Lt.test(n)?e[st.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?st.removeAttr(e,n):Mt&&Ht||!Lt.test(n)?e.setAttribute(!Ht&&st.propFix[n]||n,n):e[st.camelCase("default-"+n)]=e[n]=!0,n}},Mt&&Ht||(st.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return st.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t
},set:function(e,n,r){return st.nodeName(e,"input")?(e.defaultValue=n,t):Ct&&Ct.set(e,n,r)}}),Ht||(Ct=st.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},st.attrHooks.contenteditable={get:Ct.get,set:function(e,t,n){Ct.set(e,""===t?!1:t,n)}},st.each(["width","height"],function(e,n){st.attrHooks[n]=st.extend(st.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),st.support.hrefNormalized||(st.each(["href","src","width","height"],function(e,n){st.attrHooks[n]=st.extend(st.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),st.each(["href","src"],function(e,t){st.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),st.support.style||(st.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),st.support.optSelected||(st.propHooks.selected=st.extend(st.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),st.support.enctype||(st.propFix.enctype="encoding"),st.support.checkOn||st.each(["radio","checkbox"],function(){st.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),st.each(["radio","checkbox"],function(){st.valHooks[this]=st.extend(st.valHooks[this],{set:function(e,n){return st.isArray(n)?e.checked=st.inArray(st(e).val(),n)>=0:t}})});var qt=/^(?:input|select|textarea)$/i,_t=/^key/,Ft=/^(?:mouse|contextmenu)|click/,Ot=/^(?:focusinfocus|focusoutblur)$/,Bt=/^([^.]*)(?:\.(.+)|)$/;st.event={global:{},add:function(e,n,r,i,o){var a,s,u,l,c,f,p,d,h,g,m,y=3!==e.nodeType&&8!==e.nodeType&&st._data(e);if(y){for(r.handler&&(a=r,r=a.handler,o=a.selector),r.guid||(r.guid=st.guid++),(l=y.events)||(l=y.events={}),(s=y.handle)||(s=y.handle=function(e){return st===t||e&&st.event.triggered===e.type?t:st.event.dispatch.apply(s.elem,arguments)},s.elem=e),n=(n||"").match(lt)||[""],c=n.length;c--;)u=Bt.exec(n[c])||[],h=m=u[1],g=(u[2]||"").split(".").sort(),p=st.event.special[h]||{},h=(o?p.delegateType:p.bindType)||h,p=st.event.special[h]||{},f=st.extend({type:h,origType:m,data:i,handler:r,guid:r.guid,selector:o,needsContext:o&&st.expr.match.needsContext.test(o),namespace:g.join(".")},a),(d=l[h])||(d=l[h]=[],d.delegateCount=0,p.setup&&p.setup.call(e,i,g,s)!==!1||(e.addEventListener?e.addEventListener(h,s,!1):e.attachEvent&&e.attachEvent("on"+h,s))),p.add&&(p.add.call(e,f),f.handler.guid||(f.handler.guid=r.guid)),o?d.splice(d.delegateCount++,0,f):d.push(f),st.event.global[h]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,m=st.hasData(e)&&st._data(e);if(m&&(u=m.events)){for(t=(t||"").match(lt)||[""],l=t.length;l--;)if(s=Bt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){for(f=st.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&f.teardown.call(e,h,m.handle)!==!1||st.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)st.event.remove(e,d+t[l],n,r,!0);st.isEmptyObject(u)&&(delete m.handle,st._removeData(e,"events"))}},trigger:function(n,r,i,o){var a,s,u,l,c,f,p,d=[i||V],h=n.type||n,g=n.namespace?n.namespace.split("."):[];if(s=u=i=i||V,3!==i.nodeType&&8!==i.nodeType&&!Ot.test(h+st.event.triggered)&&(h.indexOf(".")>=0&&(g=h.split("."),h=g.shift(),g.sort()),c=0>h.indexOf(":")&&"on"+h,n=n[st.expando]?n:new st.Event(h,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=g.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:st.makeArray(r,[n]),p=st.event.special[h]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!st.isWindow(i)){for(l=p.delegateType||h,Ot.test(l+h)||(s=s.parentNode);s;s=s.parentNode)d.push(s),u=s;u===(i.ownerDocument||V)&&d.push(u.defaultView||u.parentWindow||e)}for(a=0;(s=d[a++])&&!n.isPropagationStopped();)n.type=a>1?l:p.bindType||h,f=(st._data(s,"events")||{})[n.type]&&st._data(s,"handle"),f&&f.apply(s,r),f=c&&s[c],f&&st.acceptData(s)&&f.apply&&f.apply(s,r)===!1&&n.preventDefault();if(n.type=h,!(o||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===h&&st.nodeName(i,"a")||!st.acceptData(i)||!c||!i[h]||st.isWindow(i))){u=i[c],u&&(i[c]=null),st.event.triggered=h;try{i[h]()}catch(m){}st.event.triggered=t,u&&(i[c]=u)}return n.result}},dispatch:function(e){e=st.event.fix(e);var n,r,i,o,a,s=[],u=nt.call(arguments),l=(st._data(this,"events")||{})[e.type]||[],c=st.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){for(s=st.event.handlers.call(this,e,l),n=0;(o=s[n++])&&!e.isPropagationStopped();)for(e.currentTarget=o.elem,r=0;(a=o.handlers[r++])&&!e.isImmediatePropagationStopped();)(!e.namespace_re||e.namespace_re.test(a.namespace))&&(e.handleObj=a,e.data=a.data,i=((st.event.special[a.origType]||{}).handle||a.handler).apply(o.elem,u),i!==t&&(e.result=i)===!1&&(e.preventDefault(),e.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(l.disabled!==!0||"click"!==e.type){for(i=[],r=0;u>r;r++)a=n[r],o=a.selector+" ",i[o]===t&&(i[o]=a.needsContext?st(o,this).index(l)>=0:st.find(o,this,null,[l]).length),i[o]&&i.push(a);i.length&&s.push({elem:l,handlers:i})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[st.expando])return e;var t,n,r=e,i=st.event.fixHooks[e.type]||{},o=i.props?this.props.concat(i.props):this.props;for(e=new st.Event(r),t=o.length;t--;)n=o[t],e[n]=r[n];return e.target||(e.target=r.srcElement||V),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,i.filter?i.filter(e,r):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,a=n.button,s=n.fromElement;return null==e.pageX&&null!=n.clientX&&(r=e.target.ownerDocument||V,i=r.documentElement,o=r.body,e.pageX=n.clientX+(i&&i.scrollLeft||o&&o.scrollLeft||0)-(i&&i.clientLeft||o&&o.clientLeft||0),e.pageY=n.clientY+(i&&i.scrollTop||o&&o.scrollTop||0)-(i&&i.clientTop||o&&o.clientTop||0)),!e.relatedTarget&&s&&(e.relatedTarget=s===e.target?n.toElement:s),e.which||a===t||(e.which=1&a?1:2&a?3:4&a?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return st.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==V.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===V.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=st.extend(new st.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?st.event.trigger(i,null,t):st.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},st.removeEvent=V.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,n,r){var i="on"+n;e.detachEvent&&(e[i]===t&&(e[i]=null),e.detachEvent(i,r))},st.Event=function(e,n){return this instanceof st.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?u:l):this.type=e,n&&st.extend(this,n),this.timeStamp=e&&e.timeStamp||st.now(),this[st.expando]=!0,t):new st.Event(e,n)},st.Event.prototype={isDefaultPrevented:l,isPropagationStopped:l,isImmediatePropagationStopped:l,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=u,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=u,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=u,this.stopPropagation()}},st.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){st.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!st.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),st.support.submitBubbles||(st.event.special.submit={setup:function(){return st.nodeName(this,"form")?!1:(st.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=st.nodeName(n,"input")||st.nodeName(n,"button")?n.form:t;r&&!st._data(r,"submitBubbles")&&(st.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),st._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&st.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return st.nodeName(this,"form")?!1:(st.event.remove(this,"._submit"),t)}}),st.support.changeBubbles||(st.event.special.change={setup:function(){return qt.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(st.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),st.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),st.event.simulate("change",this,e,!0)})),!1):(st.event.add(this,"beforeactivate._change",function(e){var t=e.target;qt.test(t.nodeName)&&!st._data(t,"changeBubbles")&&(st.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||st.event.simulate("change",this.parentNode,e,!0)}),st._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return st.event.remove(this,"._change"),!qt.test(this.nodeName)}}),st.support.focusinBubbles||st.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){st.event.simulate(t,e.target,st.event.fix(e),!0)};st.event.special[t]={setup:function(){0===n++&&V.addEventListener(e,r,!0)},teardown:function(){0===--n&&V.removeEventListener(e,r,!0)}}}),st.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(s in e)this.on(s,n,r,e[s],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=l;else if(!i)return this;return 1===o&&(a=i,i=function(e){return st().off(e),a.apply(this,arguments)},i.guid=a.guid||(a.guid=st.guid++)),this.each(function(){st.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,st(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=l),this.each(function(){st.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){st.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?st.event.trigger(e,n,r,!0):t},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),st.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){st.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)},_t.test(t)&&(st.event.fixHooks[t]=st.event.keyHooks),Ft.test(t)&&(st.event.fixHooks[t]=st.event.mouseHooks)}),function(e,t){function n(e){return ht.test(e+"")}function r(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>C.cacheLength&&delete e[t.shift()],e[n]=r}}function i(e){return e[P]=!0,e}function o(e){var t=L.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function a(e,t,n,r){var i,o,a,s,u,l,c,d,h,g;if((t?t.ownerDocument||t:R)!==L&&D(t),t=t||L,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!M&&!r){if(i=gt.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&O(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return Q.apply(n,K.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&W.getByClassName&&t.getElementsByClassName)return Q.apply(n,K.call(t.getElementsByClassName(a),0)),n}if(W.qsa&&!q.test(e)){if(c=!0,d=P,h=t,g=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){for(l=f(e),(c=t.getAttribute("id"))?d=c.replace(vt,"\\$&"):t.setAttribute("id",d),d="[id='"+d+"'] ",u=l.length;u--;)l[u]=d+p(l[u]);h=dt.test(e)&&t.parentNode||t,g=l.join(",")}if(g)try{return Q.apply(n,K.call(h.querySelectorAll(g),0)),n}catch(m){}finally{c||t.removeAttribute("id")}}}return x(e.replace(at,"$1"),t,n,r)}function s(e,t){for(var n=e&&t&&e.nextSibling;n;n=n.nextSibling)if(n===t)return-1;return e?1:-1}function u(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function l(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function c(e){return i(function(t){return t=+t,i(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function f(e,t){var n,r,i,o,s,u,l,c=X[e+" "];if(c)return t?0:c.slice(0);for(s=e,u=[],l=C.preFilter;s;){(!n||(r=ut.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(i=[])),n=!1,(r=lt.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(at," ")}),s=s.slice(n.length));for(o in C.filter)!(r=pt[o].exec(s))||l[o]&&!(r=l[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?a.error(e):X(e,u).slice(0)}function p(e){for(var t=0,n=e.length,r="";n>t;t++)r+=e[t].value;return r}function d(e,t,n){var r=t.dir,i=n&&"parentNode"===t.dir,o=I++;return t.first?function(t,n,o){for(;t=t[r];)if(1===t.nodeType||i)return e(t,n,o)}:function(t,n,a){var s,u,l,c=$+" "+o;if(a){for(;t=t[r];)if((1===t.nodeType||i)&&e(t,n,a))return!0}else for(;t=t[r];)if(1===t.nodeType||i)if(l=t[P]||(t[P]={}),(u=l[r])&&u[0]===c){if((s=u[1])===!0||s===N)return s===!0}else if(u=l[r]=[c],u[1]=e(t,n,a)||N,u[1]===!0)return!0}}function h(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function g(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function m(e,t,n,r,o,a){return r&&!r[P]&&(r=m(r)),o&&!o[P]&&(o=m(o,a)),i(function(i,a,s,u){var l,c,f,p=[],d=[],h=a.length,m=i||b(t||"*",s.nodeType?[s]:s,[]),y=!e||!i&&t?m:g(m,p,e,s,u),v=n?o||(i?e:h||r)?[]:a:y;if(n&&n(y,v,s,u),r)for(l=g(v,d),r(l,[],s,u),c=l.length;c--;)(f=l[c])&&(v[d[c]]=!(y[d[c]]=f));if(i){if(o||e){if(o){for(l=[],c=v.length;c--;)(f=v[c])&&l.push(y[c]=f);o(null,v=[],l,u)}for(c=v.length;c--;)(f=v[c])&&(l=o?Z.call(i,f):p[c])>-1&&(i[l]=!(a[l]=f))}}else v=g(v===a?v.splice(h,v.length):v),o?o(null,a,v,u):Q.apply(a,v)})}function y(e){for(var t,n,r,i=e.length,o=C.relative[e[0].type],a=o||C.relative[" "],s=o?1:0,u=d(function(e){return e===t},a,!0),l=d(function(e){return Z.call(t,e)>-1},a,!0),c=[function(e,n,r){return!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r))}];i>s;s++)if(n=C.relative[e[s].type])c=[d(h(c),n)];else{if(n=C.filter[e[s].type].apply(null,e[s].matches),n[P]){for(r=++s;i>r&&!C.relative[e[r].type];r++);return m(s>1&&h(c),s>1&&p(e.slice(0,s-1)).replace(at,"$1"),n,r>s&&y(e.slice(s,r)),i>r&&y(e=e.slice(r)),i>r&&p(e))}c.push(n)}return h(c)}function v(e,t){var n=0,r=t.length>0,o=e.length>0,s=function(i,s,u,l,c){var f,p,d,h=[],m=0,y="0",v=i&&[],b=null!=c,x=j,T=i||o&&C.find.TAG("*",c&&s.parentNode||s),w=$+=null==x?1:Math.E;for(b&&(j=s!==L&&s,N=n);null!=(f=T[y]);y++){if(o&&f){for(p=0;d=e[p];p++)if(d(f,s,u)){l.push(f);break}b&&($=w,N=++n)}r&&((f=!d&&f)&&m--,i&&v.push(f))}if(m+=y,r&&y!==m){for(p=0;d=t[p];p++)d(v,h,s,u);if(i){if(m>0)for(;y--;)v[y]||h[y]||(h[y]=G.call(l));h=g(h)}Q.apply(l,h),b&&!i&&h.length>0&&m+t.length>1&&a.uniqueSort(l)}return b&&($=w,j=x),v};return r?i(s):s}function b(e,t,n){for(var r=0,i=t.length;i>r;r++)a(e,t[r],n);return n}function x(e,t,n,r){var i,o,a,s,u,l=f(e);if(!r&&1===l.length){if(o=l[0]=l[0].slice(0),o.length>2&&"ID"===(a=o[0]).type&&9===t.nodeType&&!M&&C.relative[o[1].type]){if(t=C.find.ID(a.matches[0].replace(xt,Tt),t)[0],!t)return n;e=e.slice(o.shift().value.length)}for(i=pt.needsContext.test(e)?-1:o.length-1;i>=0&&(a=o[i],!C.relative[s=a.type]);i--)if((u=C.find[s])&&(r=u(a.matches[0].replace(xt,Tt),dt.test(o[0].type)&&t.parentNode||t))){if(o.splice(i,1),e=r.length&&p(o),!e)return Q.apply(n,K.call(r,0)),n;break}}return S(e,l)(r,t,M,n,dt.test(e)),n}function T(){}var w,N,C,k,E,S,A,j,D,L,H,M,q,_,F,O,B,P="sizzle"+-new Date,R=e.document,W={},$=0,I=0,z=r(),X=r(),U=r(),V=typeof t,Y=1<<31,J=[],G=J.pop,Q=J.push,K=J.slice,Z=J.indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(this[t]===e)return t;return-1},et="[\\x20\\t\\r\\n\\f]",tt="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",nt=tt.replace("w","w#"),rt="([*^$|!~]?=)",it="\\["+et+"*("+tt+")"+et+"*(?:"+rt+et+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+nt+")|)|)"+et+"*\\]",ot=":("+tt+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+it.replace(3,8)+")*)|.*)\\)|)",at=RegExp("^"+et+"+|((?:^|[^\\\\])(?:\\\\.)*)"+et+"+$","g"),ut=RegExp("^"+et+"*,"+et+"*"),lt=RegExp("^"+et+"*([\\x20\\t\\r\\n\\f>+~])"+et+"*"),ct=RegExp(ot),ft=RegExp("^"+nt+"$"),pt={ID:RegExp("^#("+tt+")"),CLASS:RegExp("^\\.("+tt+")"),NAME:RegExp("^\\[name=['\"]?("+tt+")['\"]?\\]"),TAG:RegExp("^("+tt.replace("w","w*")+")"),ATTR:RegExp("^"+it),PSEUDO:RegExp("^"+ot),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+et+"*(even|odd|(([+-]|)(\\d*)n|)"+et+"*(?:([+-]|)"+et+"*(\\d+)|))"+et+"*\\)|)","i"),needsContext:RegExp("^"+et+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+et+"*((?:-\\d)?\\d*)"+et+"*\\)|)(?=[^-]|$)","i")},dt=/[\x20\t\r\n\f]*[+~]/,ht=/\{\s*\[native code\]\s*\}/,gt=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,mt=/^(?:input|select|textarea|button)$/i,yt=/^h\d$/i,vt=/'|\\/g,bt=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,xt=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,Tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{K.call(H.childNodes,0)[0].nodeType}catch(wt){K=function(e){for(var t,n=[];t=this[e];e++)n.push(t);return n}}E=a.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},D=a.setDocument=function(e){var r=e?e.ownerDocument||e:R;return r!==L&&9===r.nodeType&&r.documentElement?(L=r,H=r.documentElement,M=E(r),W.tagNameNoComments=o(function(e){return e.appendChild(r.createComment("")),!e.getElementsByTagName("*").length}),W.attributes=o(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),W.getByClassName=o(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),W.getByName=o(function(e){e.id=P+0,e.innerHTML="<a name='"+P+"'></a><div name='"+P+"'></div>",H.insertBefore(e,H.firstChild);var t=r.getElementsByName&&r.getElementsByName(P).length===2+r.getElementsByName(P+0).length;return W.getIdNotName=!r.getElementById(P),H.removeChild(e),t}),C.attrHandle=o(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==V&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},W.getIdNotName?(C.find.ID=function(e,t){if(typeof t.getElementById!==V&&!M){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},C.filter.ID=function(e){var t=e.replace(xt,Tt);return function(e){return e.getAttribute("id")===t}}):(C.find.ID=function(e,n){if(typeof n.getElementById!==V&&!M){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==V&&r.getAttributeNode("id").value===e?[r]:t:[]}},C.filter.ID=function(e){var t=e.replace(xt,Tt);return function(e){var n=typeof e.getAttributeNode!==V&&e.getAttributeNode("id");return n&&n.value===t}}),C.find.TAG=W.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==V?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i];i++)1===n.nodeType&&r.push(n);return r}return o},C.find.NAME=W.getByName&&function(e,n){return typeof n.getElementsByName!==V?n.getElementsByName(name):t},C.find.CLASS=W.getByClassName&&function(e,n){return typeof n.getElementsByClassName===V||M?t:n.getElementsByClassName(e)},_=[],q=[":focus"],(W.qsa=n(r.querySelectorAll))&&(o(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||q.push("\\["+et+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||q.push(":checked")}),o(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&q.push("[*^$]="+et+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),q.push(",.*:")})),(W.matchesSelector=n(F=H.matchesSelector||H.mozMatchesSelector||H.webkitMatchesSelector||H.oMatchesSelector||H.msMatchesSelector))&&o(function(e){W.disconnectedMatch=F.call(e,"div"),F.call(e,"[s!='']:x"),_.push("!=",ot)}),q=RegExp(q.join("|")),_=RegExp(_.join("|")),O=n(H.contains)||H.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},B=H.compareDocumentPosition?function(e,t){var n;return e===t?(A=!0,0):(n=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&n||e.parentNode&&11===e.parentNode.nodeType?e===r||O(R,e)?-1:t===r||O(R,t)?1:0:4&n?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var n,i=0,o=e.parentNode,a=t.parentNode,u=[e],l=[t];if(e===t)return A=!0,0;if(e.sourceIndex&&t.sourceIndex)return(~t.sourceIndex||Y)-(O(R,e)&&~e.sourceIndex||Y);if(!o||!a)return e===r?-1:t===r?1:o?-1:a?1:0;if(o===a)return s(e,t);for(n=e;n=n.parentNode;)u.unshift(n);for(n=t;n=n.parentNode;)l.unshift(n);for(;u[i]===l[i];)i++;return i?s(u[i],l[i]):u[i]===R?-1:l[i]===R?1:0},A=!1,[0,0].sort(B),W.detectDuplicates=A,L):L},a.matches=function(e,t){return a(e,null,null,t)},a.matchesSelector=function(e,t){if((e.ownerDocument||e)!==L&&D(e),t=t.replace(bt,"='$1']"),!(!W.matchesSelector||M||_&&_.test(t)||q.test(t)))try{var n=F.call(e,t);if(n||W.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return a(t,L,null,[e]).length>0},a.contains=function(e,t){return(e.ownerDocument||e)!==L&&D(e),O(e,t)},a.attr=function(e,t){var n;return(e.ownerDocument||e)!==L&&D(e),M||(t=t.toLowerCase()),(n=C.attrHandle[t])?n(e):M||W.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},a.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},a.uniqueSort=function(e){var t,n=[],r=1,i=0;if(A=!W.detectDuplicates,e.sort(B),A){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));for(;i--;)e.splice(n[i],1)}return e},k=a.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=k(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=k(t);return n},C=a.selectors={cacheLength:50,createPseudo:i,match:pt,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(xt,Tt),e[3]=(e[4]||e[5]||"").replace(xt,Tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||a.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&a.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return pt.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&ct.test(n)&&(t=f(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(xt,Tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=z[e+" "];return t||(t=RegExp("(^|"+et+")"+e+"("+et+"|$)"))&&z(e,function(e){return t.test(e.className||typeof e.getAttribute!==V&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=a.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.substr(i.length-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.substr(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){for(;g;){for(f=t;f=f[g];)if(s?f.nodeName.toLowerCase()===y:1===f.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){for(c=m[P]||(m[P]={}),l=c[e]||[],d=l[0]===$&&l[1],p=l[0]===$&&l[2],f=d&&m.childNodes[d];f=++d&&f&&f[g]||(p=d=0)||h.pop();)if(1===f.nodeType&&++p&&f===t){c[e]=[$,d,p];break}}else if(v&&(l=(t[P]||(t[P]={}))[e])&&l[0]===$)p=l[1];else for(;(f=++d&&f&&f[g]||(p=d=0)||h.pop())&&((s?f.nodeName.toLowerCase()!==y:1!==f.nodeType)||!++p||(v&&((f[P]||(f[P]={}))[e]=[$,p]),f!==t)););return p-=i,p===r||0===p%r&&p/r>=0}}},PSEUDO:function(e,t){var n,r=C.pseudos[e]||C.setFilters[e.toLowerCase()]||a.error("unsupported pseudo: "+e);return r[P]?r(t):r.length>1?(n=[e,e,"",t],C.setFilters.hasOwnProperty(e.toLowerCase())?i(function(e,n){for(var i,o=r(e,t),a=o.length;a--;)i=Z.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:i(function(e){var t=[],n=[],r=S(e.replace(at,"$1"));return r[P]?i(function(e,t,n,i){for(var o,a=r(e,null,i,[]),s=e.length;s--;)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:i(function(e){return function(t){return a(e,t).length>0}}),contains:i(function(e){return function(t){return(t.textContent||t.innerText||k(t)).indexOf(e)>-1}}),lang:i(function(e){return ft.test(e||"")||a.error("unsupported lang: "+e),e=e.replace(xt,Tt).toLowerCase(),function(t){var n;do if(n=M?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===H},focus:function(e){return e===L.activeElement&&(!L.hasFocus||L.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!C.pseudos.empty(e)},header:function(e){return yt.test(e.nodeName)},input:function(e){return mt.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:c(function(){return[0]}),last:c(function(e,t){return[t-1]}),eq:c(function(e,t,n){return[0>n?n+t:n]}),even:c(function(e,t){for(var n=0;t>n;n+=2)e.push(n);return e}),odd:c(function(e,t){for(var n=1;t>n;n+=2)e.push(n);return e}),lt:c(function(e,t,n){for(var r=0>n?n+t:n;--r>=0;)e.push(r);return e}),gt:c(function(e,t,n){for(var r=0>n?n+t:n;t>++r;)e.push(r);return e})}};for(w in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})C.pseudos[w]=u(w);for(w in{submit:!0,reset:!0})C.pseudos[w]=l(w);S=a.compile=function(e,t){var n,r=[],i=[],o=U[e+" "];if(!o){for(t||(t=f(e)),n=t.length;n--;)o=y(t[n]),o[P]?r.push(o):i.push(o);o=U(e,v(i,r))}return o},C.pseudos.nth=C.pseudos.eq,C.filters=T.prototype=C.pseudos,C.setFilters=new T,D(),a.attr=st.attr,st.find=a,st.expr=a.selectors,st.expr[":"]=st.expr.pseudos,st.unique=a.uniqueSort,st.text=a.getText,st.isXMLDoc=a.isXML,st.contains=a.contains}(e);var Pt=/Until$/,Rt=/^(?:parents|prev(?:Until|All))/,Wt=/^.[^:#\[\.,]*$/,$t=st.expr.match.needsContext,It={children:!0,contents:!0,next:!0,prev:!0};st.fn.extend({find:function(e){var t,n,r;if("string"!=typeof e)return r=this,this.pushStack(st(e).filter(function(){for(t=0;r.length>t;t++)if(st.contains(r[t],this))return!0}));for(n=[],t=0;this.length>t;t++)st.find(e,this[t],n);return n=this.pushStack(st.unique(n)),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=st(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(st.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(f(this,e,!1))},filter:function(e){return this.pushStack(f(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?$t.test(e)?st(e,this.context).index(this[0])>=0:st.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){for(var n,r=0,i=this.length,o=[],a=$t.test(e)||"string"!=typeof e?st(e,t||this.context):0;i>r;r++)for(n=this[r];n&&n.ownerDocument&&n!==t&&11!==n.nodeType;){if(a?a.index(n)>-1:st.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}return this.pushStack(o.length>1?st.unique(o):o)},index:function(e){return e?"string"==typeof e?st.inArray(this[0],st(e)):st.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?st(e,t):st.makeArray(e&&e.nodeType?[e]:e),r=st.merge(this.get(),n);return this.pushStack(st.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),st.fn.andSelf=st.fn.addBack,st.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return st.dir(e,"parentNode")},parentsUntil:function(e,t,n){return st.dir(e,"parentNode",n)},next:function(e){return c(e,"nextSibling")},prev:function(e){return c(e,"previousSibling")
},nextAll:function(e){return st.dir(e,"nextSibling")},prevAll:function(e){return st.dir(e,"previousSibling")},nextUntil:function(e,t,n){return st.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return st.dir(e,"previousSibling",n)},siblings:function(e){return st.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return st.sibling(e.firstChild)},contents:function(e){return st.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:st.merge([],e.childNodes)}},function(e,t){st.fn[e]=function(n,r){var i=st.map(this,t,n);return Pt.test(e)||(r=n),r&&"string"==typeof r&&(i=st.filter(r,i)),i=this.length>1&&!It[e]?st.unique(i):i,this.length>1&&Rt.test(e)&&(i=i.reverse()),this.pushStack(i)}}),st.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?st.find.matchesSelector(t[0],e)?[t[0]]:[]:st.find.matches(e,t)},dir:function(e,n,r){for(var i=[],o=e[n];o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!st(o).is(r));)1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});var zt="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",Xt=/ jQuery\d+="(?:null|\d+)"/g,Ut=RegExp("<(?:"+zt+")[\\s/>]","i"),Vt=/^\s+/,Yt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,Jt=/<([\w:]+)/,Gt=/<tbody/i,Qt=/<|&#?\w+;/,Kt=/<(?:script|style|link)/i,Zt=/^(?:checkbox|radio)$/i,en=/checked\s*(?:[^=]|=\s*.checked.)/i,tn=/^$|\/(?:java|ecma)script/i,nn=/^true\/(.*)/,rn=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,on={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:st.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},an=p(V),sn=an.appendChild(V.createElement("div"));on.optgroup=on.option,on.tbody=on.tfoot=on.colgroup=on.caption=on.thead,on.th=on.td,st.fn.extend({text:function(e){return st.access(this,function(e){return e===t?st.text(this):this.empty().append((this[0]&&this[0].ownerDocument||V).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(st.isFunction(e))return this.each(function(t){st(this).wrapAll(e.call(this,t))});if(this[0]){var t=st(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstChild&&1===e.firstChild.nodeType;)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return st.isFunction(e)?this.each(function(t){st(this).wrapInner(e.call(this,t))}):this.each(function(){var t=st(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=st.isFunction(e);return this.each(function(n){st(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){st.nodeName(this,"body")||st(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){for(var n,r=0;null!=(n=this[r]);r++)(!e||st.filter(e,[n]).length>0)&&(t||1!==n.nodeType||st.cleanData(b(n)),n.parentNode&&(t&&st.contains(n.ownerDocument,n)&&m(b(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++){for(1===e.nodeType&&st.cleanData(b(e,!1));e.firstChild;)e.removeChild(e.firstChild);e.options&&st.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return st.clone(this,e,t)})},html:function(e){return st.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(Xt,""):t;if(!("string"!=typeof e||Kt.test(e)||!st.support.htmlSerialize&&Ut.test(e)||!st.support.leadingWhitespace&&Vt.test(e)||on[(Jt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(Yt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(st.cleanData(b(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=st.isFunction(e);return t||"string"==typeof e||(e=st(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;(n&&1===this.nodeType||11===this.nodeType)&&(st(this).remove(),t?t.parentNode.insertBefore(e,t):n.appendChild(e))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=et.apply([],e);var i,o,a,s,u,l,c=0,f=this.length,p=this,m=f-1,y=e[0],v=st.isFunction(y);if(v||!(1>=f||"string"!=typeof y||st.support.checkClone)&&en.test(y))return this.each(function(i){var o=p.eq(i);v&&(e[0]=y.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(f&&(i=st.buildFragment(e,this[0].ownerDocument,!1,this),o=i.firstChild,1===i.childNodes.length&&(i=o),o)){for(n=n&&st.nodeName(o,"tr"),a=st.map(b(i,"script"),h),s=a.length;f>c;c++)u=i,c!==m&&(u=st.clone(u,!0,!0),s&&st.merge(a,b(u,"script"))),r.call(n&&st.nodeName(this[c],"table")?d(this[c],"tbody"):this[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,st.map(a,g),c=0;s>c;c++)u=a[c],tn.test(u.type||"")&&!st._data(u,"globalEval")&&st.contains(l,u)&&(u.src?st.ajax({url:u.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):st.globalEval((u.text||u.textContent||u.innerHTML||"").replace(rn,"")));i=o=null}return this}}),st.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){st.fn[e]=function(e){for(var n,r=0,i=[],o=st(e),a=o.length-1;a>=r;r++)n=r===a?this:this.clone(!0),st(o[r])[t](n),tt.apply(i,n.get());return this.pushStack(i)}}),st.extend({clone:function(e,t,n){var r,i,o,a,s,u=st.contains(e.ownerDocument,e);if(st.support.html5Clone||st.isXMLDoc(e)||!Ut.test("<"+e.nodeName+">")?s=e.cloneNode(!0):(sn.innerHTML=e.outerHTML,sn.removeChild(s=sn.firstChild)),!(st.support.noCloneEvent&&st.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||st.isXMLDoc(e)))for(r=b(s),i=b(e),a=0;null!=(o=i[a]);++a)r[a]&&v(o,r[a]);if(t)if(n)for(i=i||b(e),r=r||b(s),a=0;null!=(o=i[a]);a++)y(o,r[a]);else y(e,s);return r=b(s,"script"),r.length>0&&m(r,!u&&b(e,"script")),r=i=o=null,s},buildFragment:function(e,t,n,r){for(var i,o,a,s,u,l,c,f=e.length,d=p(t),h=[],g=0;f>g;g++)if(o=e[g],o||0===o)if("object"===st.type(o))st.merge(h,o.nodeType?[o]:o);else if(Qt.test(o)){for(s=s||d.appendChild(t.createElement("div")),a=(Jt.exec(o)||["",""])[1].toLowerCase(),u=on[a]||on._default,s.innerHTML=u[1]+o.replace(Yt,"<$1></$2>")+u[2],c=u[0];c--;)s=s.lastChild;if(!st.support.leadingWhitespace&&Vt.test(o)&&h.push(t.createTextNode(Vt.exec(o)[0])),!st.support.tbody)for(o="table"!==a||Gt.test(o)?"<table>"!==u[1]||Gt.test(o)?0:s:s.firstChild,c=o&&o.childNodes.length;c--;)st.nodeName(l=o.childNodes[c],"tbody")&&!l.childNodes.length&&o.removeChild(l);for(st.merge(h,s.childNodes),s.textContent="";s.firstChild;)s.removeChild(s.firstChild);s=d.lastChild}else h.push(t.createTextNode(o));for(s&&d.removeChild(s),st.support.appendChecked||st.grep(b(h,"input"),x),g=0;o=h[g++];)if((!r||-1===st.inArray(o,r))&&(i=st.contains(o.ownerDocument,o),s=b(d.appendChild(o),"script"),i&&m(s),n))for(c=0;o=s[c++];)tn.test(o.type||"")&&n.push(o);return s=null,d},cleanData:function(e,n){for(var r,i,o,a,s=0,u=st.expando,l=st.cache,c=st.support.deleteExpando,f=st.event.special;null!=(o=e[s]);s++)if((n||st.acceptData(o))&&(i=o[u],r=i&&l[i])){if(r.events)for(a in r.events)f[a]?st.event.remove(o,a):st.removeEvent(o,a,r.handle);l[i]&&(delete l[i],c?delete o[u]:o.removeAttribute!==t?o.removeAttribute(u):o[u]=null,K.push(i))}}});var un,ln,cn,fn=/alpha\([^)]*\)/i,pn=/opacity\s*=\s*([^)]*)/,dn=/^(top|right|bottom|left)$/,hn=/^(none|table(?!-c[ea]).+)/,gn=/^margin/,mn=RegExp("^("+ut+")(.*)$","i"),yn=RegExp("^("+ut+")(?!px)[a-z%]+$","i"),vn=RegExp("^([+-])=("+ut+")","i"),bn={BODY:"block"},xn={position:"absolute",visibility:"hidden",display:"block"},Tn={letterSpacing:0,fontWeight:400},wn=["Top","Right","Bottom","Left"],Nn=["Webkit","O","Moz","ms"];st.fn.extend({css:function(e,n){return st.access(this,function(e,n,r){var i,o,a={},s=0;if(st.isArray(n)){for(i=ln(e),o=n.length;o>s;s++)a[n[s]]=st.css(e,n[s],!1,i);return a}return r!==t?st.style(e,n,r):st.css(e,n)},e,n,arguments.length>1)},show:function(){return N(this,!0)},hide:function(){return N(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:w(this))?st(this).show():st(this).hide()})}}),st.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=un(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":st.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,u=st.camelCase(n),l=e.style;if(n=st.cssProps[u]||(st.cssProps[u]=T(l,u)),s=st.cssHooks[n]||st.cssHooks[u],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:l[n];if(a=typeof r,"string"===a&&(o=vn.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(st.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||st.cssNumber[u]||(r+="px"),st.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{l[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,u=st.camelCase(n);return n=st.cssProps[u]||(st.cssProps[u]=T(e.style,u)),s=st.cssHooks[n]||st.cssHooks[u],s&&"get"in s&&(o=s.get(e,!0,r)),o===t&&(o=un(e,n,i)),"normal"===o&&n in Tn&&(o=Tn[n]),r?(a=parseFloat(o),r===!0||st.isNumeric(a)?a||0:o):o},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),e.getComputedStyle?(ln=function(t){return e.getComputedStyle(t,null)},un=function(e,n,r){var i,o,a,s=r||ln(e),u=s?s.getPropertyValue(n)||s[n]:t,l=e.style;return s&&(""!==u||st.contains(e.ownerDocument,e)||(u=st.style(e,n)),yn.test(u)&&gn.test(n)&&(i=l.width,o=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=u,u=s.width,l.width=i,l.minWidth=o,l.maxWidth=a)),u}):V.documentElement.currentStyle&&(ln=function(e){return e.currentStyle},un=function(e,n,r){var i,o,a,s=r||ln(e),u=s?s[n]:t,l=e.style;return null==u&&l&&l[n]&&(u=l[n]),yn.test(u)&&!dn.test(n)&&(i=l.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),l.left="fontSize"===n?"1em":u,u=l.pixelLeft+"px",l.left=i,a&&(o.left=a)),""===u?"auto":u}),st.each(["height","width"],function(e,n){st.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&hn.test(st.css(e,"display"))?st.swap(e,xn,function(){return E(e,n,i)}):E(e,n,i):t},set:function(e,t,r){var i=r&&ln(e);return C(e,t,r?k(e,n,r,st.support.boxSizing&&"border-box"===st.css(e,"boxSizing",!1,i),i):0)}}}),st.support.opacity||(st.cssHooks.opacity={get:function(e,t){return pn.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=st.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===st.trim(o.replace(fn,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=fn.test(o)?o.replace(fn,i):o+" "+i)}}),st(function(){st.support.reliableMarginRight||(st.cssHooks.marginRight={get:function(e,n){return n?st.swap(e,{display:"inline-block"},un,[e,"marginRight"]):t}}),!st.support.pixelPosition&&st.fn.position&&st.each(["top","left"],function(e,n){st.cssHooks[n]={get:function(e,r){return r?(r=un(e,n),yn.test(r)?st(e).position()[n]+"px":r):t}}})}),st.expr&&st.expr.filters&&(st.expr.filters.hidden=function(e){return 0===e.offsetWidth&&0===e.offsetHeight||!st.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||st.css(e,"display"))},st.expr.filters.visible=function(e){return!st.expr.filters.hidden(e)}),st.each({margin:"",padding:"",border:"Width"},function(e,t){st.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];4>r;r++)i[e+wn[r]+t]=o[r]||o[r-2]||o[0];return i}},gn.test(e)||(st.cssHooks[e+t].set=C)});var Cn=/%20/g,kn=/\[\]$/,En=/\r?\n/g,Sn=/^(?:submit|button|image|reset)$/i,An=/^(?:input|select|textarea|keygen)/i;st.fn.extend({serialize:function(){return st.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=st.prop(this,"elements");return e?st.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!st(this).is(":disabled")&&An.test(this.nodeName)&&!Sn.test(e)&&(this.checked||!Zt.test(e))}).map(function(e,t){var n=st(this).val();return null==n?null:st.isArray(n)?st.map(n,function(e){return{name:t.name,value:e.replace(En,"\r\n")}}):{name:t.name,value:n.replace(En,"\r\n")}}).get()}}),st.param=function(e,n){var r,i=[],o=function(e,t){t=st.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=st.ajaxSettings&&st.ajaxSettings.traditional),st.isArray(e)||e.jquery&&!st.isPlainObject(e))st.each(e,function(){o(this.name,this.value)});else for(r in e)j(r,e[r],n,o);return i.join("&").replace(Cn,"+")};var jn,Dn,Ln=st.now(),Hn=/\?/,Mn=/#.*$/,qn=/([?&])_=[^&]*/,_n=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Fn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,On=/^(?:GET|HEAD)$/,Bn=/^\/\//,Pn=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Rn=st.fn.load,Wn={},$n={},In="*/".concat("*");try{Dn=Y.href}catch(zn){Dn=V.createElement("a"),Dn.href="",Dn=Dn.href}jn=Pn.exec(Dn.toLowerCase())||[],st.fn.load=function(e,n,r){if("string"!=typeof e&&Rn)return Rn.apply(this,arguments);var i,o,a,s=this,u=e.indexOf(" ");return u>=0&&(i=e.slice(u,e.length),e=e.slice(0,u)),st.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(o="POST"),s.length>0&&st.ajax({url:e,type:o,dataType:"html",data:n}).done(function(e){a=arguments,s.html(i?st("<div>").append(st.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,a||[e.responseText,t,e])}),this},st.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){st.fn[t]=function(e){return this.on(t,e)}}),st.each(["get","post"],function(e,n){st[n]=function(e,r,i,o){return st.isFunction(r)&&(o=o||i,i=r,r=t),st.ajax({url:e,type:n,dataType:o,data:r,success:i})}}),st.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Dn,type:"GET",isLocal:Fn.test(jn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":In,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":st.parseJSON,"text xml":st.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?H(H(e,st.ajaxSettings),t):H(st.ajaxSettings,e)},ajaxPrefilter:D(Wn),ajaxTransport:D($n),ajax:function(e,n){function r(e,n,r,s){var l,f,v,b,T,N=n;2!==x&&(x=2,u&&clearTimeout(u),i=t,a=s||"",w.readyState=e>0?4:0,r&&(b=M(p,w,r)),e>=200&&300>e||304===e?(p.ifModified&&(T=w.getResponseHeader("Last-Modified"),T&&(st.lastModified[o]=T),T=w.getResponseHeader("etag"),T&&(st.etag[o]=T)),304===e?(l=!0,N="notmodified"):(l=q(p,b),N=l.state,f=l.data,v=l.error,l=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),w.status=e,w.statusText=(n||N)+"",l?g.resolveWith(d,[f,N,w]):g.rejectWith(d,[w,N,v]),w.statusCode(y),y=t,c&&h.trigger(l?"ajaxSuccess":"ajaxError",[w,p,l?f:v]),m.fireWith(d,[w,N]),c&&(h.trigger("ajaxComplete",[w,p]),--st.active||st.event.trigger("ajaxStop")))}"object"==typeof e&&(n=e,e=t),n=n||{};var i,o,a,s,u,l,c,f,p=st.ajaxSetup({},n),d=p.context||p,h=p.context&&(d.nodeType||d.jquery)?st(d):st.event,g=st.Deferred(),m=st.Callbacks("once memory"),y=p.statusCode||{},v={},b={},x=0,T="canceled",w={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!s)for(s={};t=_n.exec(a);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=b[n]=b[n]||e,v[e]=t),this},overrideMimeType:function(e){return x||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)y[t]=[y[t],e[t]];else w.always(e[w.status]);return this},abort:function(e){var t=e||T;return i&&i.abort(t),r(0,t),this}};if(g.promise(w).complete=m.add,w.success=w.done,w.error=w.fail,p.url=((e||p.url||Dn)+"").replace(Mn,"").replace(Bn,jn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=st.trim(p.dataType||"*").toLowerCase().match(lt)||[""],null==p.crossDomain&&(l=Pn.exec(p.url.toLowerCase()),p.crossDomain=!(!l||l[1]===jn[1]&&l[2]===jn[2]&&(l[3]||("http:"===l[1]?80:443))==(jn[3]||("http:"===jn[1]?80:443)))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=st.param(p.data,p.traditional)),L(Wn,p,n,w),2===x)return w;c=p.global,c&&0===st.active++&&st.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!On.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(Hn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=qn.test(o)?o.replace(qn,"$1_="+Ln++):o+(Hn.test(o)?"&":"?")+"_="+Ln++)),p.ifModified&&(st.lastModified[o]&&w.setRequestHeader("If-Modified-Since",st.lastModified[o]),st.etag[o]&&w.setRequestHeader("If-None-Match",st.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&w.setRequestHeader("Content-Type",p.contentType),w.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+In+"; q=0.01":""):p.accepts["*"]);for(f in p.headers)w.setRequestHeader(f,p.headers[f]);if(p.beforeSend&&(p.beforeSend.call(d,w,p)===!1||2===x))return w.abort();T="abort";for(f in{success:1,error:1,complete:1})w[f](p[f]);if(i=L($n,p,n,w)){w.readyState=1,c&&h.trigger("ajaxSend",[w,p]),p.async&&p.timeout>0&&(u=setTimeout(function(){w.abort("timeout")},p.timeout));try{x=1,i.send(v,r)}catch(N){if(!(2>x))throw N;r(-1,N)}}else r(-1,"No Transport");return w},getScript:function(e,n){return st.get(e,t,n,"script")},getJSON:function(e,t,n){return st.get(e,t,n,"json")}}),st.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return st.globalEval(e),e}}}),st.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),st.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=V.head||st("head")[0]||V.documentElement;return{send:function(t,i){n=V.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Xn=[],Un=/(=)\?(?=&|$)|\?\?/;st.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xn.pop()||st.expando+"_"+Ln++;return this[e]=!0,e}}),st.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,u=n.jsonp!==!1&&(Un.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Un.test(n.data)&&"data");return u||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=st.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,u?n[u]=n[u].replace(Un,"$1"+o):n.jsonp!==!1&&(n.url+=(Hn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||st.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Xn.push(o)),s&&st.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Vn,Yn,Jn=0,Gn=e.ActiveXObject&&function(){var e;for(e in Vn)Vn[e](t,!0)};st.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&_()||F()}:_,Yn=st.ajaxSettings.xhr(),st.support.cors=!!Yn&&"withCredentials"in Yn,Yn=st.support.ajax=!!Yn,Yn&&st.ajaxTransport(function(n){if(!n.crossDomain||st.support.cors){var r;return{send:function(i,o){var a,s,u=n.xhr();if(n.username?u.open(n.type,n.url,n.async,n.username,n.password):u.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)u[s]=n.xhrFields[s];n.mimeType&&u.overrideMimeType&&u.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)u.setRequestHeader(s,i[s])}catch(l){}u.send(n.hasContent&&n.data||null),r=function(e,i){var s,l,c,f,p;try{if(r&&(i||4===u.readyState))if(r=t,a&&(u.onreadystatechange=st.noop,Gn&&delete Vn[a]),i)4!==u.readyState&&u.abort();else{f={},s=u.status,p=u.responseXML,c=u.getAllResponseHeaders(),p&&p.documentElement&&(f.xml=p),"string"==typeof u.responseText&&(f.text=u.responseText);try{l=u.statusText}catch(d){l=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=f.text?200:404}}catch(h){i||o(-1,h)}f&&o(s,l,f,c)},n.async?4===u.readyState?setTimeout(r):(a=++Jn,Gn&&(Vn||(Vn={},st(e).unload(Gn)),Vn[a]=r),u.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Qn,Kn,Zn=/^(?:toggle|show|hide)$/,er=RegExp("^(?:([+-])=|)("+ut+")([a-z%]*)$","i"),tr=/queueHooks$/,nr=[W],rr={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=er.exec(t),a=i.cur(),s=+a||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(st.cssNumber[e]?"":"px"),"px"!==r&&s){s=st.css(i.elem,e,!0)||n||1;do u=u||".5",s/=u,st.style(i.elem,e,s+r);while(u!==(u=i.cur()/a)&&1!==u&&--l)}i.unit=r,i.start=s,i.end=o[1]?s+(o[1]+1)*n:n}return i}]};st.Animation=st.extend(P,{tweener:function(e,t){st.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");for(var n,r=0,i=e.length;i>r;r++)n=e[r],rr[n]=rr[n]||[],rr[n].unshift(t)},prefilter:function(e,t){t?nr.unshift(e):nr.push(e)}}),st.Tween=$,$.prototype={constructor:$,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(st.cssNumber[n]?"":"px")},cur:function(){var e=$.propHooks[this.prop];return e&&e.get?e.get(this):$.propHooks._default.get(this)},run:function(e){var t,n=$.propHooks[this.prop];return this.pos=t=this.options.duration?st.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):$.propHooks._default.set(this),this}},$.prototype.init.prototype=$.prototype,$.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=st.css(e.elem,e.prop,"auto"),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){st.fx.step[e.prop]?st.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[st.cssProps[e.prop]]||st.cssHooks[e.prop])?st.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},$.propHooks.scrollTop=$.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},st.each(["toggle","show","hide"],function(e,t){var n=st.fn[t];st.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(I(t,!0),e,r,i)}}),st.fn.extend({fadeTo:function(e,t,n,r){return this.filter(w).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=st.isEmptyObject(e),o=st.speed(t,n,r),a=function(){var t=P(this,st.extend({},e),o);a.finish=function(){t.stop(!0)},(i||st._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=st.timers,a=st._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&tr.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&st.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=st._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=st.timers,a=r?r.length:0;for(n.finish=!0,st.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),st.each({slideDown:I("show"),slideUp:I("hide"),slideToggle:I("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){st.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),st.speed=function(e,t,n){var r=e&&"object"==typeof e?st.extend({},e):{complete:n||!n&&t||st.isFunction(e)&&e,duration:e,easing:n&&t||t&&!st.isFunction(t)&&t};return r.duration=st.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in st.fx.speeds?st.fx.speeds[r.duration]:st.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){st.isFunction(r.old)&&r.old.call(this),r.queue&&st.dequeue(this,r.queue)},r},st.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},st.timers=[],st.fx=$.prototype.init,st.fx.tick=function(){var e,n=st.timers,r=0;for(Qn=st.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||st.fx.stop(),Qn=t},st.fx.timer=function(e){e()&&st.timers.push(e)&&st.fx.start()},st.fx.interval=13,st.fx.start=function(){Kn||(Kn=setInterval(st.fx.tick,st.fx.interval))},st.fx.stop=function(){clearInterval(Kn),Kn=null},st.fx.speeds={slow:600,fast:200,_default:400},st.fx.step={},st.expr&&st.expr.filters&&(st.expr.filters.animated=function(e){return st.grep(st.timers,function(t){return e===t.elem}).length}),st.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){st.offset.setOffset(this,e,t)});var n,r,i={top:0,left:0},o=this[0],a=o&&o.ownerDocument;if(a)return n=a.documentElement,st.contains(n,o)?(o.getBoundingClientRect!==t&&(i=o.getBoundingClientRect()),r=z(a),{top:i.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:i.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):i},st.offset={setOffset:function(e,t,n){var r=st.css(e,"position");"static"===r&&(e.style.position="relative");var i,o,a=st(e),s=a.offset(),u=st.css(e,"top"),l=st.css(e,"left"),c=("absolute"===r||"fixed"===r)&&st.inArray("auto",[u,l])>-1,f={},p={};c?(p=a.position(),i=p.top,o=p.left):(i=parseFloat(u)||0,o=parseFloat(l)||0),st.isFunction(t)&&(t=t.call(e,n,s)),null!=t.top&&(f.top=t.top-s.top+i),null!=t.left&&(f.left=t.left-s.left+o),"using"in t?t.using.call(e,f):a.css(f)}},st.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===st.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),st.nodeName(e[0],"html")||(n=e.offset()),n.top+=st.css(e[0],"borderTopWidth",!0),n.left+=st.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-st.css(r,"marginTop",!0),left:t.left-n.left-st.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||V.documentElement;e&&!st.nodeName(e,"html")&&"static"===st.css(e,"position");)e=e.offsetParent;return e||V.documentElement})}}),st.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);st.fn[e]=function(i){return st.access(this,function(e,i,o){var a=z(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?st(a).scrollLeft():o,r?o:st(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}}),st.each({Height:"height",Width:"width"},function(e,n){st.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){st.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return st.access(this,function(n,r,i){var o;return st.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?st.css(n,r,s):st.style(n,r,i,s)},n,a?i:t,a,null)}})}),e.jQuery=e.$=st,"function"==typeof define&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return st})})(window);
//@ sourceMappingURL=jquery.min.map </script>	
		<script  > /*! jQuery UI - v1.10.0 - 2013-01-17
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.10.0",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.0",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.0",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var element,
			that = this,
			elementInDom = false,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		element = this.element[0];
		while ( element && (element = element.parentNode) ) {
			if (element === document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.addBack()
			.each(function() {
				if(this === event.target) {
					handle = true;
				}
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				o.containment === "document" ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				o.containment === "document" ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				(o.containment === "document" ? 0 : $(window).scrollLeft()) + $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
				(o.containment === "document" ? 0 : $(window).scrollTop()) + ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor !== Array) {
			c = $(o.containment);
			ce = c[0];

			if(!ce) {
				return;
			}

			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor === Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName),
			pageX = event.pageX,
			pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
			if(this.containment) {
			if (this.relative_container){
				co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = true;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.ui.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {

		var min,
			o = $(this).data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt(group[0].style.zIndex, 10) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

(function( $, undefined ) {

function isOverAxis( x, reference, size ) {
	return ( x > reference ) && ( x < ( reference + size ) );
}

$.widget("ui.droppable", {
	version: "1.10.0",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var i = 0,
			drop = $.ui.ddmanager.droppables[this.options.scope];

		for ( ; i < drop.length; i++ ) {
			if ( drop[i] === this ) {
				drop.splice(i, 1);
			}
		}

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key === "accept") {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.addClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger("activate", event, this.ui(draggable));
		}
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.removeClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger("deactivate", event, this.ui(draggable));
		}
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.addClass(this.options.hoverClass);
			}
			this._trigger("over", event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger("out", event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return false;
		}

		this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, "ui-droppable");
			if(
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
				$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) {
			return false;
		}

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) {
				this.element.removeClass(this.options.activeClass);
			}
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger("drop", event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) {
		return false;
	}

	var draggableLeft, draggableTop,
		x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
		l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case "fit":
			return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
		case "intersect":
			return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
				x2 - (draggable.helperProportions.width / 2) < r && // Left Half
				t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
				y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
		case "pointer":
			draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
			draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
			return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );
		case "touch":
			return (
				(y1 >= t && y1 <= b) ||	// Top edge touching
				(y2 >= t && y2 <= b) ||	// Bottom edge touching
				(y1 < t && y2 > b)		// Surrounded vertically
			) && (
				(x1 >= l && x1 <= r) ||	// Left edge touching
				(x2 >= l && x2 <= r) ||	// Right edge touching
				(x1 < l && x2 > r)		// Surrounded horizontally
			);
		default:
			return false;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function(t, event) {

		var i, j,
			m = $.ui.ddmanager.droppables[t.options.scope] || [],
			type = event ? event.type : null, // workaround for #2317
			list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

		droppablesLoop: for (i = 0; i < m.length; i++) {

			//No disabled and non-accepted
			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
				continue;
			}

			// Filter out elements in the current dragged item
			for (j=0; j < list.length; j++) {
				if(list[j] === m[i].element[0]) {
					m[i].proportions.height = 0;
					continue droppablesLoop;
				}
			}

			m[i].visible = m[i].element.css("display") !== "none";
			if(!m[i].visible) {
				continue;
			}

			//Activate the droppable if used directly from draggables
			if(type === "mousedown") {
				m[i]._activate.call(m[i], event);
			}

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) {
				return;
			}
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
				dropped = this._drop.call(this, event) || dropped;
			}

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) {
			$.ui.ddmanager.prepareOffsets(draggable, event);
		}

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect(draggable, this, this.options.tolerance),
				c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
			if(!c) {
				return;
			}

			if (this.options.greedy) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents(":data(ui-droppable)").filter(function () {
					return $.data(this, "ui-droppable").options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], "ui-droppable");
					parentInstance.greedyChild = (c === "isover");
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c === "isover") {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c === "isout") {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

})(jQuery);

(function( $, undefined ) {

function num(v) {
	return parseInt(v, 10) || 0;
}

function isNumber(value) {
	return !isNaN(parseInt(value, 10));
}

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.10.0",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},
	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"ui-resizable", this.element.data("ui-resizable")
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
		if(this.handles.constructor === String) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for(i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-"+handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				//Insert into internal handles object and append to element
				this.handles[handle] = ".ui-resizable-"+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = $(this.handles[i], this.element).show();
				}

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(".ui-resizable-handle", this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
			};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			iniPos = this.element.position(),
			el = this.element;

		this.resizing = true;

		// bugfix for http://dev.jquery.com/ticket/1749
		if ( (/absolute/).test( el.css("position") ) ) {
			el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
		} else if (el.is(".ui-draggable")) {
			el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		curleft = num(this.helper.css("left"));
		curtop = num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			prevTop = this.position.top,
			prevLeft = this.position.left,
			prevWidth = this.size.width,
			prevHeight = this.size.height,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		if (!trigger) {
			return false;
		}

		// Calculate the attrs that will be change
		data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		if (this.position.top !== prevTop) {
			props.top = this.position.top + "px";
		}
		if (this.position.left !== prevLeft) {
			props.left = this.position.left + "px";
		}
		if (this.size.width !== prevWidth) {
			props.width = this.size.width + "px";
		}
		if (this.size.height !== prevHeight) {
			props.height = this.size.height + "px";
		}
		el.css(props);

		if (!this._helper && this._proportionallyResizeElements.length) {
			this._proportionallyResize();
		}

		// Call the user callback if the element was resized
		if ( ! $.isEmptyObject(props) ) {
			this._trigger("resize", event, this.ui());
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
				paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

				for ( j = 0; j < borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left +"px",
				top: this.elementOffset.top +"px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $(this).data("ui-resizable"),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

		if (!ce) {
			return;
		}

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc === document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			element = $(ce);
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
			height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset, cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] !== document && (/static/).test(ce.css("position"))) {
			cop = co;
		}

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
		hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		isParent = that.containerElement.get(0) === that.element.parent().get(0);
		isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

		if(isParent && isOffsetRelative) {
			woset -= that.parentData.left;
		}

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
		}
	},

	stop: function(){
		var that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $(that.helper),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

		if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).data("ui-resizable");
		if (that.ghost) {
			that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).data("ui-resizable");
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	version: "1.10.0",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var selectees,
			that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this),
					pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass("ui-selected"),
					selecting: $this.hasClass("ui-selecting"),
					unselecting: $this.hasClass("ui-unselecting")
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this,
			options = this.options;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled) {
			return;
		}

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(".ui-selected").each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass("ui-selected");
				selectee.selected = false;
				selectee.$element.addClass("ui-unselecting");
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().addBack().each(function() {
			var doSelect,
				selectee = $.data(this, "selectable-item");
			if (selectee) {
				doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {

		this.dragged = true;

		if (this.options.disabled) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[0],
			y1 = this.opos[1],
			x2 = event.pageX,
			y2 = event.pageY;

		if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item"),
				hit = false;

			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element === that.element[0]) {
				return;
			}

			if (options.tolerance === "touch") {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance === "fit") {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass("ui-unselecting");
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass("ui-selecting");
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						selectee.$element.addClass("ui-selected");
						selectee.selected = true;
					} else {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;

						selectee.$element.addClass("ui-unselecting");
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		$(".ui-unselecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-unselecting");
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$(".ui-selecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);

(function( $, undefined ) {

/*jshint loopfunc: true */

function isOverAxis( x, reference, size ) {
	return ( x > reference ) && ( x < ( reference + size ) );
}

$.widget("ui.sortable", $.ui.mouse, {
	version: "1.10.0",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === "x" || (/left|right/).test(this.items[0].item.css("float")) || (/inline|table-cell/).test(this.items[0].item.css("display")) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true;

	},

	_destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget().toggleClass( "ui-sortable-disabled", !!value );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if(o.cursor) { // cursor option
			if ($("body").css("cursor")) {
				this._storedCursor = $("body").css("cursor");
			}
			$("body").css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className) {
						el.style.visibility = "hidden";
					}

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			posProperty = this.containers[innermostIndex].floating ? "left" : "top";
			sizeProperty = this.containers[innermostIndex].floating ? "width" : "height";
			base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}
				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) {
			$("body").css("cursor", this._storedCursor);
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] !== this.currentItem[0]) {
			this.helper.remove();
		}
		this.helper = null;

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);

;(jQuery.effects || (function($, undefined) {

var dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.10.0",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	return typeof speed === "string" && !$.effects.effect[ speed ];
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));

(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = "show";

$.widget( "ui.accordion", {
	version: "1.10.0",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var options = this.options;
		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// ARIA
			.attr( "role", "tablist" );

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}

		this._processPanels();
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		/*jshint maxcomplexity:15*/
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
			options.active = false;
			this.active = $();
		// active false only when collapsible is true
		} if ( options.active === false ) {
			this._activate( 0 );
		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
				options.active = false;
				this.active = $();
			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}
		// was active, active panel still exists
		} else {
			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		this.headers = this.element.find( this.options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.filter(":not(.ui-accordion-content-active)")
			.hide();
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent(),
			accordionId = this.accordionId = "ui-accordion-" +
				(this.element.attr( "id" ) || ++uid);

		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active" )
			.toggleClass( "ui-corner-all ui-corner-top" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this.headers
			.attr( "role", "tab" )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( "id" ),
					panel = header.next(),
					panelId = panel.attr( "id" );
				if ( !headerId ) {
					headerId = accordionId + "-header-" + i;
					header.attr( "id", headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + "-panel-" + i;
					panel.attr( "id", panelId );
				}
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			})
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( "activate", null, data );
	}
});

})( jQuery );

(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	version: "1.10.0",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

		this.isMultiLine = this._isMultiLine();
		this.valueMethod = this.element[ this.element.is( "input,textarea" ) ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				/*jshint maxcomplexity:15*/
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( this._appendTo() )
			.menu({
				// custom key handling for now
				input: $(),
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.zIndex( this.element.zIndex() + 1 )
			.hide()
			.data( "ui-menu" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// #7024 - Prevent accidental activation of menu items in Firefox
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				var item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item's value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn't
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "polite"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.insertAfter( this.element );

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[0].body;
		}

		return element;
	},

	_isMultiLine: function() {
		// Textareas are always multi-line
		if ( this.element.is( "textarea" ) ) {
			return true;
		}
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		if ( this.element.is( "input" ) ) {
			return false;
		}
		// All other element types are determined by whether or not they're contentEditable
		return this.element.prop( "isContentEditable" );
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( "ui-autocomplete-loading" );
			}
		};
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});

}( jQuery ));

(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /'/g, "\\'" );
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.10.0",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "",
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an "active" state
				.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.10.0",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );

(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.0" } });

var PROP_NAME = "datepicker",
	dpuuid = new Date().getTime(),
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if (inst.input.is(":visible") && !inst.input.is(":disabled")) {
				inst.input.focus();
			}
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		// #6694 - don't focus the input if it's already focused
		// this breaks the change event in IE
		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
			inst.input.is(":visible") && !inst.input.is(":disabled") && inst.input[0] !== document.activeElement) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	 * @param  elem  (jQuery object) the element of interest
	 * @return  (number[2]) the left and top borders
	 */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css("border-left-width"))),
			parseFloat(convert(elem.css("border-top-width")))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					window["DP_jQuery_" + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window["DP_jQuery_" + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window["DP_jQuery_" + dpuuid].datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2] + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10) + currentYear;
				maxYear = parseInt(yearSplit[1], 10) + currentYear;
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.0";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window["DP_jQuery_" + dpuuid] = $;

})(jQuery);

(function( $, undefined ) {

var sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget( "ui.dialog", {
	version: "1.10.0",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		closeOnEscape: true,
		closeText: "close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	_create: function() {
		this.originalCss = {
			display: this.element[0].style.display,
			width: this.element[0].style.width,
			minHeight: this.element[0].style.minHeight,
			maxHeight: this.element[0].style.maxHeight,
			height: this.element[0].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr("title");
		this.options.title = this.options.title || this.originalTitle;

		this._createWrapper();

		this.element
			.show()
			.removeAttr("title")
			.addClass("ui-dialog-content ui-widget-content")
			.appendTo( this.uiDialog );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && (element.jquery || element.nodeType) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.removeClass("ui-dialog-content ui-widget-content")
			.css( this.originalCss )
			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.stop( true, true ).remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[0] !== this.element[0] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._destroyOverlay();

		if ( !this.opener.filter(":focusable").focus().length ) {
			// Hiding a focused element doesn't trigger blur in WebKit
			// so in case we have nothing to focus on, explicitly blur the active element
			// https://bugs.webkit.org/show_bug.cgi?id=47182
			$( this.document[0].activeElement ).blur();
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		});
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this.opener = $( this.document[0].activeElement );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );
		this._show( this.uiDialog, this.options.show );

		this._focusTabbable();

		this._isOpen = true;
		this._trigger("open");
		this._trigger("focus");
	},

	_focusTabbable: function() {
		// Set focus to the first match:
		// 1. First element inside the dialog matching [autofocus]
		// 2. Tabbable element inside the content element
		// 3. Tabbable element inside the buttonpane
		// 4. The close button
		// 5. The dialog itself
		var hasFocus = this.element.find("[autofocus]");
		if ( !hasFocus.length ) {
			hasFocus = this.element.find(":tabbable");
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find(":tabbable");
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = this.document[0].activeElement,
				isActive = this.uiDialog[0] === activeElement ||
					$.contains( this.uiDialog[0], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );
		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $("<div>")
			.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
				this.options.dialogClass )
			.hide()
			.attr({
				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			})
			.appendTo( this._appendTo() );

		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB ) {
					return;
				}
				var tabbables = this.uiDialog.find(":tabbable"),
					first = tabbables.filter(":first"),
					last  = tabbables.filter(":last");

				if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
					first.focus( 1 );
					event.preventDefault();
				} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
					last.focus( 1 );
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		});

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find("[aria-describedby]").length ) {
			this.uiDialog.attr({
				"aria-describedby": this.element.uniqueId().attr("id")
			});
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $("<div>")
			.addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
			.prependTo( this.uiDialog );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {
				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest(".ui-dialog-titlebar-close") ) {
					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.focus();
				}
			}
		});

		this.uiDialogTitlebarClose = $("<button></button>")
			.button({
				label: this.options.closeText,
				icons: {
					primary: "ui-icon-closethick"
				},
				text: false
			})
			.addClass("ui-dialog-titlebar-close")
			.appendTo( this.uiDialogTitlebar );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		});

		uiDialogTitle = $("<span>")
			.uniqueId()
			.addClass("ui-dialog-title")
			.prependTo( this.uiDialogTitlebar );
		this._title( uiDialogTitle );

		this.uiDialog.attr({
			"aria-labelledby": uiDialogTitle.attr("id")
		});
	},

	_title: function( title ) {
		if ( !this.options.title ) {
			title.html("&#160;");
		}
		title.text( this.options.title );
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $("<div>")
			.addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

		this.uiButtonSet = $("<div>")
			.addClass("ui-dialog-buttonset")
			.appendTo( this.uiDialogButtonPane );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) ) {
			this.uiDialog.removeClass("ui-dialog-buttons");
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;
			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );
			// Change the context for the click callback to be the main element
			click = props.click;
			props.click = function() {
				click.apply( that.element[0], arguments );
			};
			buttonOptions = {
				icons: props.icons,
				text: props.showText
			};
			delete props.icons;
			delete props.showText;
			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet );
		});
		this.uiDialog.addClass("ui-dialog-buttons");
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this ).addClass("ui-dialog-dragging");
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this ).removeClass("ui-dialog-dragging");
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		});
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css("position"),
			resizeHandles = typeof handles === "string" ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass("ui-dialog-resizing");
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.height = $( this ).height();
				options.width = $( this ).width();
				$( this ).removeClass("ui-dialog-resizing");
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		})
		.css( "position", position );
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {
		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is(":visible");
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is(":data(ui-resizable)") ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		/*jshint maxcomplexity:15*/
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "dialogClass" ) {
			uiDialog
				.removeClass( this.options.dialogClass )
				.addClass( value );
		}

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button({
				// Ensure that we always pass a string
				label: "" + value
			});
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is(":data(ui-draggable)");
			if ( isDraggable && !value ) {
				uiDialog.draggable("destroy");
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {
			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is(":data(ui-resizable)");
			if ( isResizable && !value ) {
				uiDialog.resizable("destroy");
			}

			// currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find(".ui-dialog-title") );
		}
	},

	_size: function() {
		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css({
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			});
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if (this.uiDialog.is(":data(ui-resizable)") ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( !$.ui.dialog.overlayInstances ) {
			// Prevent use of anchors and inputs.
			// We use a delay in case the overlay is created from an
			// event that we're going to be cancelling. (#2804)
			this._delay(function() {
				// Handle .dialog().dialog("close") (#4065)
				if ( $.ui.dialog.overlayInstances ) {
					this._on( this.document, {
						focusin: function( event ) {
							if ( !$( event.target ).closest(".ui-dialog").length ) {
								event.preventDefault();
								$(".ui-dialog:visible:last .ui-dialog-content")
									.data("ui-dialog")._focusTabbable();
							}
						}
					});
				}
			});
		}

		this.overlay = $("<div>")
			.addClass("ui-widget-overlay ui-front")
			.appendTo( this.document[0].body );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		});
		$.ui.dialog.overlayInstances++;
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		$.ui.dialog.overlayInstances--;
		if ( !$.ui.dialog.overlayInstances ) {
			this._off( this.document, "focusin" );
		}
		this.overlay.remove();
	}
});

$.ui.dialog.overlayInstances = 0;

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// position option with array notation
	// just override with old implementation
	$.widget( "ui.dialog", $.ui.dialog, {
		_position: function() {
			var position = this.options.position,
				myAt = [],
				offset = [ 0, 0 ],
				isVisible;

			if ( position ) {
				if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
					myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
					if ( myAt.length === 1 ) {
						myAt[1] = myAt[0];
					}

					$.each( [ "left", "top" ], function( i, offsetPosition ) {
						if ( +myAt[ i ] === myAt[ i ] ) {
							offset[ i ] = myAt[ i ];
							myAt[ i ] = offsetPosition;
						}
					});

					position = {
						my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
							myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
						at: myAt.join(" ")
					};
				}

				position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
			} else {
				position = $.ui.dialog.prototype.options.position;
			}

			// need to show the dialog to get the actual offset in the position plugin
			isVisible = this.uiDialog.is(":visible");
			if ( !isVisible ) {
				this.uiDialog.show();
			}
			this.uiDialog.position( position );
			if ( !isVisible ) {
				this.uiDialog.hide();
			}
		}
	});
}

}( jQuery ) );

(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );

(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

(function( $, undefined ) {

$.widget( "ui.menu", {
	version: "1.10.0",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		// flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-state-disabled > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item:has(a)": function( event ) {
				var target = $( event.target ).closest( ".ui-menu-item" );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.mouseHandled = true;

					this.select( event );
					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) ) {
						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( ".ui-menu" ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.children( "a" )
				.removeUniqueId()
				.removeClass( "ui-corner-all ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		/*jshint maxcomplexity:20*/
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
				return regex.test( $( this ).children( "a" ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.prev( "a" ),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );

		// Don't refresh list items that are already adapted
		menus.children( ":not(.ui-menu-item):has(a)" )
			.addClass( "ui-menu-item" )
			.attr( "role", "presentation" )
			.children( "a" )
				.uniqueId()
				.addClass( "ui-corner-all" )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( ":not(.ui-menu-item)" ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-—–\s]/.test( item.text() ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.element.find( ".ui-menu-icon" )
				.removeClass( this.options.icons.submenu )
				.addClass( value.submenu );
		}
		this._super( key, value );
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( "a" ).addClass( "ui-state-focus" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.children( "a:first" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( "a" ).removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( "a.ui-state-active" )
				.removeClass( "ui-state-active" );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.children( ".ui-menu-item" )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});

}( jQuery ));

(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

(function( $, undefined ) {

$.widget( "ui.progressbar", {
	version: "1.10.0",
	options: {
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				role: "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}

		this._super( key, value );
	},

	_percentage: function() {
		return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
});

})( jQuery );

(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.10.0",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	_create: function() {
		var i, handleCount,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				} else if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				} else if ( $.isArray( o.values ) ) {
					o.values = o.values.slice(0);
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		handleCount = ( o.values && o.values.length ) || 1;

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});

		this._setOption( "disabled", o.disabled );

		this._on( this.handles, this._handleEvents );

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.prop( "disabled", true );
				} else {
					this.handles.prop( "disabled", false );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			/*jshint maxcomplexity:25*/
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}

});

}(jQuery));

(function( $ ) {

function modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.10.0",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// format the value, but don't constrain
		this._value( this.element.val(), true );

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			this.buttons.first().find( ".ui-icon" )
				.removeClass( this.options.icons.up )
				.addClass( value.up );
			this.buttons.last().find( ".ui-icon" )
				.removeClass( this.options.icons.down )
				.addClass( value.down );
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
				this.buttons.button( "disable" );
			} else {
				this.element.prop( "disabled", false );
				this.buttons.button( "enable" );
			}
		}
	},

	_setOptions: modifier(function( options ) {
		this._super( options );
		this._value( this.element.val() );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * this.options.step );
			this._stop();
		}
	},

	stepDown: modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * -this.options.step );
			this._stop();
		}
	},

	pageUp: modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}( jQuery ) );

(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length > 1 &&
		decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
			decodeURIComponent( location.href.replace( rhash, "" ) );
}

$.widget( "ui.tabs", {
	version: "1.10.0",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		/*jshint maxcomplexity:15*/
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

})( jQuery );

(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
	var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
	describedby.push( id );
	elem
		.data( "ui-tooltip-id", id )
		.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
}

function removeDescribedBy( elem ) {
	var id = elem.data( "ui-tooltip-id" ),
		describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
		index = $.inArray( id, describedby );
	if ( index !== -1 ) {
		describedby.splice( index, 1 );
	}

	elem.removeData( "ui-tooltip-id" );
	describedby = $.trim( describedby.join( " " ) );
	if ( describedby ) {
		elem.attr( "aria-describedby", describedby );
	} else {
		elem.removeAttr( "aria-describedby" );
	}
}

$.widget( "ui.tooltip", {
	version: "1.10.0",
	options: {
		content: function() {
			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";
			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.attr( "title", "" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( "ui-tooltip-open" ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, events, delayedShow,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltip = this._tooltip( target );
		addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );

		events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			},
			remove: function() {
				this._removeTooltip( tooltip );
			}
		};
		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// only set title if we had one before (see comment in _open())
		if ( target.data( "ui-tooltip-title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );
		// Remove 'remove' binding only on delegated targets
		if ( target[0] !== this.element[0] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		this.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var id = "ui-tooltip-" + increments++,
			tooltip = $( "<div>" )
				.attr({
					id: id,
					role: "tooltip"
				})
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) );
		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );
		tooltip.appendTo( this.document[0].body );
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? $( "#" + id ) : $();
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
				element.removeData( "ui-tooltip-title" );
			}
		});
	}
});

}( jQuery ) );
 </script>
		<script id="user_data"  > var slide_background = "data:image/jpeg;base64,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2222222622223CAAAEMkkkkkkkklkkkokkgSAIkpmyyTBBOX3DCU2H5OH39DU76CWey6xSpM2Df95vQa7eBBoLhgC6zM7n23qQnznUstsgAEkMlklklvAXm2222223W+22zBBhkkkkkkkkkkkkklkklGSBkkem2SYAP+227TH12JHW/Riaj6LWf3rS6WM+ZvT0i3ZapPNliUB/fbu/X+j5aF+RcLssCIEklkkkkkkkP07m2222222zSSGkkkkkkkkkkkkkkklkssiQAEp82feaAB+22USG28q327ASXq5yX3/dohgNko62zaREtaQFtQpmyTXR6W+3fbK2+f1edRBEklElklkkkksCm7m222222222KkkkskkkkkkskkkolkqQAEkk02zTAAa++wae+7nKC2/Tan1YTbiJC0YFBKJCwn+f8AkQCKbYQoW9sn7+rs+m4Nu01soh8ABJKJKJbJJJJIQC6Jrtttttttu1JJJJJJJJJZJJJBJJUkARJVps8kgAD99u8mNF6SvtmlW3nmGUm6VL4DaDbRQ3lU3V0rKYrDnP0228U2t332Jlen/wDGEhCCSCSQSWSSSSWQAAhfF7bbbbbZvSSSSSSSSSSSSCSyDJAESS7fdJoA/bfZNMHcXVr/AGe3S005bt4pmBoC4FNwW7iPrzbTEsthDCe0fXLyX2/c+u7fe8mFCfklMkoktkkkkkEAAABjau22223EkkkkkkskkkkElkEaAEkq22zSIAB2+3ea3n1JD23zYUxEHRtxJetwHMwKUej+HY0a8QAWHQEjbD63b372bq2n7b/08JNx2BkkksslkkkkMAAAABEwfI229skkkklkkkkgkssjABklG2yzzQB6+++aYOV8qn25bzUZYRNjJBnC6FlApnLuTUa7+ZgsBJmeeDba80U/3+f323NT2nwgYXXGkskkstkkkkogAAAAAAAbTA7EkkkkkkklEkkmRAIEsu31aRBBe327yey1hCW23Ytt1pIFoNFwllLIFBu/Im8HqCM8NCJLVkQGffMz03ACO27byWW27TJ19vOgkkkkkkkksMgAAAAABEJ+qgdkkkkkskskyIAAko+2ueQJE232XDD+klW2244KweJyEtPK0sz+AshNTqbf3VmnFJW8E1Z19yblSCzySA22wDCy+2bTSpyl5bAkknkkkkklgIABAMkkkkg6K+wV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";
 </script>
		<script  > var winW=0;
var winH=0;
var count=0;
var touchStartX = 0;
var touchStartY = 0;
var subElemCount=0;
var level=0;
var remote=false;
var edit= true;
var active=null;
var background=null;
var Remote_last="";
var ID_CT =0;
var current=null;//new Array();
//var aspect = 4/3 // 4:3
var aspect = 16/9;

function handleBackgroundSelect(evt){
	var file = evt.target.files[0];
	if (file.type.match('image.*')){
		console.log(file.type);
		var reader = new FileReader();
		reader.onload = (function(theFile){
			return function(e) {
				slide_background = e.target.result;
				set_slide_background();
				console.log("background changed");
			}
		})(file);
		reader.readAsDataURL(file);
	}	
}
	
function set_slide_background(){
	active.style.backgroundImage="url("+slide_background+")";
}

function initialize(){
	active = document.getElementById("slide_main");
	if (slide_background){
		active.style.backgroundImage="url("+slide_background+")";
		active.style.backgroundSize="100% auto";
	}
	resize();
	
	document.getElementById('file').addEventListener('change',handleBackgroundSelect,false);
	window.onresize=resize;
	if (edit== true){
		// placeholder for adding borders, and toolbar
	}
}

function first(){
	count = 0;
	subElemCount = 0; 
	attatch_listeners();
	current = slides[count];
	hide();
	load();
	if (window.fullScreenApi.supportsFullScreen) {
		window.fullScreenApi.requestFullScreen(document.body);
	}
}

function save_elem(){
   if (localStorage){
	localStorage.slide_background = slide_background;
	localStorage.savedHTML = active.innerHTML;
	localStorage.ID_CT = ID_CT;
   }
}
function load_from_store(){
   if (localStorage){
	slide_background = localStorage.slide_background;
	set_slide_background();
	active.innerHTML = localStorage.savedHTML;
	ID_CT = localStorage.ID_CT;
	for(i=1;i<=ID_CT;i++){		
		$('#outer'+i).resizable();
		$('#outer'+i).resizable( "destroy" );
		$('#outer'+i).resizable();
		$('#outer'+i).draggable({snap:true, cancel: "div.slide_text"});
	}
    }
}

function Add_elem(type){
	if (type == "text_area"){
		ID_CT ++;
		active.innerHTML += '<div id="outer'+ID_CT+'" class="text_area"><div class="handle"></div><div id="'+ID_CT+'" class="slide_text" contenteditable="true">Type your own text here</div></div>';
	 	for(i=1;i<=ID_CT;i++){		
			$('#outer'+i).resizable();
	                $('#outer'+i).resizable( "destroy" );
        	        $('#outer'+i).resizable();
                	$('#outer'+i).draggable({snap:true, cancel: "div.slide_text"});
		}
	}
}

function Remote_Slide(){
	remote=true;
	$.get("../get?id="+ID, function(data){
		console.log(data!=Remote_last);
		if (data!=Remote_last){
			Remote_last = data;
			script='<script>'+data+'</script>';
			$('body').append(script);
			console.log("updated");
		}
		setTimeout(Remote_Slide,700);
	});
}

function jump_to(slide,sub){
	count = slide;
	current = slides[count];
	hide();
	load();
	if (sub){
		for(subElemCount=0;subElemCount < sub; subElemCount++){
			current = slides[count].subElem[subElemCount];
			load();
		}
	}
}

function back(){
	if (subElemCount){
		hide();
		jump_to(count, --subElemCount);
		subElemCount;
	} else if(count>0){
		count--;
		current = slides[count];
		if(current.subElem){
			jump_to(count,current.subElem.length);
		} else {
			hide();
			load();
		}
	}
}

function attatch_listeners(){
	active.addEventListener("mouseup",next,false);
	$('body').keydown(function(e){
		if (e){
			if(e.keyCode==39){ //right
				next();
			} else if (e.keyCode == 37){ //left
				back();
			}
		}
	});
	active.addEventListener("touchstart",function(event){
		if(event.targetTouches.length==1){
			//event.preventDefault();
			//alert("hello");
			touchStartX = event.targetTouches[0].pageX;
			touchStartY = event.targetTouches[0].pageY;
		}
	}, true);
	active.addEventListener("touchmove", function(event){
		if(event.targetTouches.length == 1){		
			event.preventDefault();
			//if(event.targetTouches[0].pageX-touchStartX >30){alert("swipe");}
			touchLengthX = event.targetTouches[0].pageX-touchStartX;
			touchLengthY = event.targetTouches[0].oageY-touchStartY;
		}
	},true);
	active.addEventListener("touchend" , function(event){
		event.preventDefault();
			if (touchLengthX > 30){
				back();
			}
			if(touchLengthX < -30){
				next();
			}
	},true);
	active.addEventListener("touchcancel", function(event){event.preventDefault;},true);
}
			
function next(){
	console.log("SubElemcount = " + subElemCount);
	if ( count >= 0 && slides[count].subElem && subElemCount >= 0)
	{
		current = slides[count].subElem[subElemCount];
		subElemCount++;
		load();
		if (subElemCount == slides[count].subElem.length  )
		{
			subElemCount = -1;					//make sure we go back to 0 for the next one.
		}
	} else {
		if (subElemCount == -1){
			subElemCount = 0;
		}
		if (count >= 0){
			hide();
		}
		count ++;
		current = slides[count];
		if (count < slides.length)
		{
			load();
		} else {
			document.getElementById("slide_content").innerHTML = "<button style='font-size:1em;position:relative;height:10%; width: 16%; top:45%;left:42%' onclick='first();'>Replay</button>";
	
/*			if(ID){
				jQuery.ajax({
					type: 'GET',
					url : "../put?id="+ID+"&ended=1",
					success : function () {console.log("updated");}
			
				});
			}*/
			if(window.fullScreenApi.isFullScreen){window.fullScreenApi.cancelFullScreen(document.body);}
		}
	}

	console.log("SubElemcount = " + subElemCount);
}

function hide(){
	document.getElementById("slide_head").innerHTML="";
	document.getElementById("slide_content").innerHTML="";
}

function load(){ //load element in current;
	console.log("load(): count ="+count);
	if(ID && !remote){
		jQuery.ajax({
			type: 'GET',
			url : "../put?id="+ID+"&slide="+count+"&sub="+subElemCount,
			success : function () {console.log("updated");}
	
		});
	}
	var tag = "", tagEnd = "";
	if (current.head){
		document.getElementById("slide_head").innerHTML += current.head;
	};
    if (current.type){
		tag = "<"+current.type+">";
		tagEnd = "</"+current.type+">";
	};
	if (current.content){
		document.getElementById("slide_content").innerHTML+=tag+current.content+tagEnd;
	}; 
};	





function resize()
{
	winW = 630, winH = 460;
	var slideH =winH, slideW = winW;
	var background = $('#slide_screen');
	if (background.innerHeight && background.innerWidth){
		winW = background.innerWidth();
		winH = background.innerHeight();
	}
	if (edit){
		winW -=4;
		winH -=4;
	}
		
	if (winH * aspect < winW){ //put plack bars on sides
		slideW = winH*aspect;
		slideH = winH;
		active.style.width = slideW + "px";
		active.style.left = ((winW-slideW) / 2) + "px";
		console.log("slideH="+winH+"slideW="+slideW);
	} else{
		slideH = winW/aspect;
		slideW = winW;
		active.style.height = slideH + "px";
		active.style.top = ( (winH-slideH)/2) + "px";
		console.log("winH="+winH+", and slideH="+slideH);
	}
	active.style.width = slideW + "px";
	active.style.left = ((winW-slideW) / 2) + "px";
	active.style.height = slideH + "px";
	active.style.top = ( (winH-slideH)/2) + "px";
	var margins = ".03";//document.getElementByTag('slide_text')[0].style.margin;
	var textHeight = (slideW-(2*slideW*margins))/1024 * 30 + "px";
	active.style.fontSize=textHeight;
}
////////////////////////////////////////////////////////////////////////
(function() {
	var 
		fullScreenApi = { 
			supportsFullScreen: false,
			isFullScreen: function() { return false; }, 
			requestFullScreen: function() {}, 
			cancelFullScreen: function() {},
			fullScreenEventName: '',
			prefix: ''
		},
		browserPrefixes = 'webkit moz o ms khtml'.split(' ');
	
	// check for native support
	if (typeof document.cancelFullScreen != 'undefined') {
		fullScreenApi.supportsFullScreen = true;
	} else {	 
		// check for fullscreen support by vendor prefix
		for (var i = 0, il = browserPrefixes.length; i < il; i++ ) {
			fullScreenApi.prefix = browserPrefixes[i];
			
			if (typeof document[fullScreenApi.prefix + 'CancelFullScreen' ] != 'undefined' ) {
				fullScreenApi.supportsFullScreen = true;
				
				break;
			}
		}
	}
	
	// update methods to do something useful
	if (fullScreenApi.supportsFullScreen) {
		fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';
		
		fullScreenApi.isFullScreen = function() {
			switch (this.prefix) {	
				case '':
					return document.fullScreen;
				case 'webkit':
					return document.webkitIsFullScreen;
				default:
					return document[this.prefix + 'FullScreen'];
			}
		}
		fullScreenApi.requestFullScreen = function(el) {
			return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
		}
		fullScreenApi.cancelFullScreen = function(el) {
			return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
		}		
	}

	// export api
	window.fullScreenApi = fullScreenApi;	
})();
/////////////////////////////////////////////////////////////////////////
 </script>	
	</head>
	<body>
		<div id="toolbar">
			<button onclick="Add_elem('text_area');">textarea</button><input type="file" id="file" name="file"/>
</button><button>image</button>
		<button onclick="save_elem();">Save</button><button onclick="load_from_store();">Load</button>
		</div>
		<div id="slide_screen" class="background">

			<div id="slide_main" class="slide">
			</div>	
		</div>
	<script>initialize();</script>
	</body>
</html>
			
